COMMIT HISTORY OF REPOSITORY: Polo280-KL25Z_Labs
Polo280, 2024-06-10 : Added off functions and fixed direction
    Custom Libraries/Stepper/Stepper TPM/StepperTPM.c - modified
    Custom Libraries/Stepper/Stepper TPM/StepperTPM.h - modified
------------------------------
Polo280, 2024-06-10 : Manual mode logic working
    PCB_InspectorRTOS/CircuitVision.c - added
    PCB_InspectorRTOS/CircuitVision.h - added
------------------------------
Polo280, 2024-06-10 : Added library for TPM based Stepper control
    Custom Libraries/Stepper/Stepper Systick/Requirements/Clocks.c - renamed
    Custom Libraries/Stepper/Stepper Systick/Requirements/Clocks.h - renamed
    Custom Libraries/Stepper/Stepper Systick/Stepper.c - renamed
    Custom Libraries/Stepper/Stepper Systick/Stepper.h - renamed
    Custom Libraries/Stepper/Stepper Systick/main.c - renamed
    Custom Libraries/Stepper/Stepper Systick/main.h - renamed
    Custom Libraries/Stepper/Stepper TPM/StepperTPM.c - added
    Custom Libraries/Stepper/Stepper TPM/StepperTPM.h - added
------------------------------
Polo280, 2024-06-08 : Added Timing management using PIT Timer moduler+
    Custom Libraries/PIT Timer/PIT_Config.c - added
    Custom Libraries/PIT Timer/PIT_Config.h - added
------------------------------
Polo280, 2024-06-03 : First working version uart, updates incoming ;)
    Custom Libraries/UART Handler/UART.c - added
    Custom Libraries/UART Handler/UART.h - added
------------------------------
Polo280, 2024-05-31 : Added 4 bit LCD library
    Custom Libraries/LCD4_Bits/LCD_4BIT.c - added
    Custom Libraries/LCD4_Bits/LCD_4BIT.h - added
    Custom Libraries/LCD4_Bits/Requirements/Clocks.c - added
    Custom Libraries/LCD4_Bits/Requirements/Clocks.h - added
------------------------------
Polo280, 2024-05-31 : Added library for display 8 bits
    Custom Libraries/LCD 8 Bits/LCD_8BIT.c - added
    Custom Libraries/LCD 8 Bits/LCD_8BIT.h - added
    Custom Libraries/LCD 8 Bits/Requirements/Clocks.c - added
    Custom Libraries/LCD 8 Bits/Requirements/Clocks.h - added
------------------------------
Polo280, 2024-05-31 : Wave generator v2 with uart
    Function Generator/FuncGen.c - modified
------------------------------
Polo280, 2024-05-29 : Added first version of function generator
    Function Generator/FuncGen.c - added
    Function Generator/Requirements/Clocks.c - added
    Function Generator/Requirements/Clocks.h - added
    Function Generator/main.h - added
------------------------------
Polo280, 2024-05-28 : Updated some modules
    Custom Libraries/I2C_Display/i2cdisplay.c - modified
    Custom Libraries/I2C_Display/i2cdisplay.h - modified
    Custom Libraries/LCD 8 Bits/LCD_8BIT.c - removed
    Custom Libraries/LCD 8 Bits/LCD_8BIT.h - removed
    Custom Libraries/LCD 8 Bits/Requirements/Clocks.c - removed
    Custom Libraries/LCD 8 Bits/Requirements/Clocks.h - removed
    Custom Libraries/Stepper/Stepper.c - modified
    Custom Libraries/Stepper/Stepper.h - modified
------------------------------
Polo280, 2024-05-16 : Added first version of LCD 8 bit library
    Custom Libraries/LCD 8 Bits/LCD_8BIT.c - added
    Custom Libraries/LCD 8 Bits/LCD_8BIT.h - added
    Custom Libraries/LCD 8 Bits/Requirements/Clocks.c - added
    Custom Libraries/LCD 8 Bits/Requirements/Clocks.h - added
------------------------------
Polo280, 2024-05-15 : Fixed delay issues
    Custom Libraries/Systick Config/Clocks.c - modified
    Custom Libraries/Systick Config/Clocks.h - modified
------------------------------
Polo280, 2024-05-14 : First updates on main project
    PCB Inspector/PCB_Inspect.c - added
    PCB Inspector/Required Libraries/Functions/Clocks.c - added
    PCB Inspector/Required Libraries/Functions/RGB.c - added
    PCB Inspector/Required Libraries/Functions/Stepper.c - added
    PCB Inspector/Required Libraries/Functions/UART.c - added
    PCB Inspector/Required Libraries/Headers/Clocks.h - added
    PCB Inspector/Required Libraries/Headers/RGB.h - added
    PCB Inspector/Required Libraries/Headers/Stepper.h - added
    PCB Inspector/Required Libraries/Headers/UART.h - added
    PCB Inspector/main.h - added
------------------------------
Polo280, 2024-05-08 : First working version of stepper motor library
    Custom Libraries/Stepper/Stepper.c - modified
    Custom Libraries/Stepper/main.c - modified
    Custom Libraries/Stepper/main.h - modified
------------------------------
Polo280, 2024-05-07 : First version of stepper driver
    Custom Libraries/Stepper/Requirements/Clocks.c - added
    Custom Libraries/Stepper/Requirements/Clocks.h - added
    Custom Libraries/Stepper/Stepper.c - added
    Custom Libraries/Stepper/Stepper.h - added
    Custom Libraries/Stepper/main.c - added
    Custom Libraries/Stepper/main.h - added
------------------------------
Polo280, 2024-05-06 : Updates on timing management, not working yet
    Custom Libraries/I2C_Display/Functions/clocks.c - added
    Custom Libraries/I2C_Display/Functions/rgb.c - added
    Custom Libraries/I2C_Display/Headers/clocks.h - added
    Custom Libraries/I2C_Display/Headers/rgb.h - added
    Custom Libraries/I2C_Display/main.c - modified
    Custom Libraries/I2C_Display/main.h - modified
------------------------------
Polo280, 2024-05-05 : Clock auxiliar v1
    Custom Libraries/Systick Config/Clocks.c - added
    Custom Libraries/Systick Config/Clocks.h - added
------------------------------
Polo280, 2024-05-04 : 12 bit multichan conversion for x and y
    ADC/Joystick/Joystick.c - modified
    ADC/Joystick/main.h - modified
------------------------------
Polo280, 2024-05-04 : Joystick V1
    ADC/Joystick/Joystick.c - added
    ADC/Joystick/main.h - added
------------------------------
Polo280, 2024-05-03 : Added folder for custom libraries
    Custom Libraries/Builtin RGB/RGB.c - added
    Custom Libraries/Builtin RGB/RGB.h - added
    Custom Libraries/I2C_Display/i2cdisplay.c - renamed
    Custom Libraries/I2C_Display/i2cdisplay.h - renamed
    Custom Libraries/I2C_Display/main.c - renamed
    Custom Libraries/I2C_Display/main.h - renamed
------------------------------
Polo280, 2024-05-03 : Refine
    I2C_Display/i2cdisplay.c - modified
    I2C_Display/main.c - modified
------------------------------
Polo280, 2024-04-29 : I2C Display Library (timing issues)
    I2C_Display/i2cdisplay.c - added
    I2C_Display/i2cdisplay.h - added
    I2C_Display/main.c - added
    I2C_Display/main.h - added
------------------------------
Polo280, 2024-04-28 : UART print
    Protocols/UART_PRINT.c - added
------------------------------
Polo280, 2024-04-15 : RGB practice
    RGB.c - added
------------------------------
Jorge GonzÃ¡lez, 2024-04-15 : Initial commit
------------------------------
File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/RGB.c

#include "MKL25Z4.h"

// Definitions
enum RGB_LED {
	RED = 0x40000,
	GREEN = 0x20,
	BLUE = 0x80000
};

void ClockConfig(void);
void GPIO_Config(void);

// Functionalities
void LED_On(GPIO_Type * , uint32_t);
void LED_Off(GPIO_Type * , uint32_t);

int main(void){

	// Enable clocks
	ClockConfig();
	GPIO_Config();

	// Turn off LEDS
	GPIOD->PDOR |= 0x20;        // Green
	GPIOB->PDOR |= 0x40000;     // Red
	GPIOB->PDOR |= 0x80000;     // Blue

	// Turn off alternative
	//LED_Off(GPIOD, GREEN);
	//LED_Off(GPIOB, RED);
	//LED_Off(GPIOB, BLUE);

	// Turn on leds sequentially

	GPIOD->PDOR &= ~0x20;    // blue
	//GPIOB->PDOR &= ~0x40000;   // RED
	//GPIOB->PDOR &= ~0x80000; // Green

	// Easier alternative
	//LED_On(GPIOD, GREEN);
	//LED_On(GPIOB, RED);
	//LED_On(GPIOB, BLUE);

	// Main loop
	while(1){

	}

	return 0;
}

// Clock configurations
void ClockConfig(void){
	SIM->SCGC5 |= 0x400;   // Enable clock port B
	SIM->SCGC5 |= 0x1000;  // Enable clock port D
}

// GPIO Configurations
void GPIO_Config(void){
	// Set pins as GPIOS
	PORTB->PCR[19] = 0x100;
	PORTB->PCR[18] = 0x100;
	PORTD->PCR[5] = 0x100;

	GPIOB->PDDR |= 0x80000;  // Enable (bit) pin 19 from GPIOB as output (Green)
	GPIOD->PDDR |= 0x20;     // Enable (bit) pin 5 from GPIOD as output (Blue)
	GPIOB->PDDR |= 0x40000;  // Enable (bit) pin 18 from GPIOB as output (Red)
}

// Turn on LED
void LED_On(GPIO_Type *port, uint32_t pin){
	port->PDOR &= ~pin;
}

// Turn off LED
void LED_Off(GPIO_Type *port, uint32_t pin){
	port->PDOR |= pin;
}




==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/PCB Inspector/PCB_Inspect.c

#include "main.h"

static void ADC_Config(void);
static void I2C_Config(void);
static void SteppersInit(void);
static void InitAll(void);
static void ErrorHandler(void);

// Time aux
uint64_t blink_aux = 0, stepper_aux = 0, adc_aux = 0, print_aux = 0;
// Store ADC results
uint16_t adc_res = 0, adc_res2 = 0;
// Systick pointer
volatile const uint64_t *systicks;
// UART buffer
char uart_c[50];
// Stepper instances
Stepper stpX, stpY, stpZ;

int main(void){
	// Init peripherals
	InitAll();
	// Set systick pointer
	systicks = GetSysTicks();
	// Main loop
	while(1){
		// Run stepper
		if(*systicks - stepper_aux >= TIME_TO_RUN_STEPPER * conv_factor){
			RunStepper(&stpX);
			stepper_aux = *systicks;
		}

		// Blink led
		if(*systicks - blink_aux >= TIME_TO_BLINK_MS * conv_factor){
			YellowToggle();
			blink_aux = *systicks;
		}

		// Read ADC and clear flag
		if(*systicks - adc_aux >= TIME_TO_READ_ADC_MS){
			adc_aux = *systicks;

			while(!(ADC0->SC1[0] & 0x80)) {   // Wait for end of conversion flag
				if(*systicks - adc_aux >= ADC_TIMEOUT_MS * conv_factor){
					break;
				}
			}
			// Assign ADC result
			adc_res = (ADC0->R[0] >> 4) - 10;
			adc_aux = *systicks;

			// Start ADC conversion in channel 4
			ADC0->SC1[0] = 0x04;

			while(!(ADC0->SC1[0] & 0x80)) {   // Wait for end of conversion flag
				if(*systicks - adc_aux >= ADC_TIMEOUT_MS * conv_factor){
					break;
				}
			}
			// Store result
			adc_res2 = (ADC0->R[0] >> 4) - 10;
			adc_aux = *systicks;
			// Start ADC conversion in channel 0
			ADC0->SC1[0] = 0;
		}
		SetStepperVelocity(&stpX, adc_res);
		SetStepperVelocity(&stpY, adc_res2);

		// UART Print
		if(*systicks - print_aux >= TIME_TO_PRINT_MS * conv_factor){
			// Assign values to the buffer
			snprintf(uart_c, sizeof(uart_c), "X: %d, Y: %d\n", SystemCoreClock, adc_res2);

			for(uint8_t i=0; i < strlen(uart_c); i++){
				print_aux = *systicks;
				UART0->D = uart_c[i];
				while(!(UART0->S1 & 0x40)){  // Wait for the TX buffer to be empty
					if(*systicks - print_aux >= UART_TIMEOUT_MS * conv_factor)
						break;
				}
			}
			print_aux = *systicks;
		}
	}
	return 0;
}

void InitAll(void){
	//MCG_Config();
	ClkInitIt(CLK_TENS_MICROS);

	UART_Config();	  // UART Config
	I2C_Config();	  // I2C Config
	ADC_Config();	  // ADC Config

	RGB_Init();	      // Init RGB led
	SteppersInit();   // Init steppers
	if (LCD_DefaultInit(I2C0, systicks) == ERROR)
		ErrorHandler();
	//LCD_DefaultInit(I2C0, systicks);
}

void ADC_Config(void){
	SIM->SCGC5 |= 0x2000;       // Enable PORTE clock
	SIM->SCGC6 |= 0x8000000;    // ADC0 clock
	PORTE->PCR[20] = 0x000;     // Configure pin PORTE 20 as analog
	PORTE->PCR[21] = 0x000;     // Configure pin PORTE 21 as analog

	ADC0->SC2 &= ~0x40;         // Software trigger
	ADC0->CFG1 = 0x40 | 0x04 | 0x00 | 0x10;

	// Start ADC conversion in channel 0
	ADC0->SC1[0] = 0;
}

// Configure I2C
void I2C_Config(void){
	SIM->SCGC4 |= 0x40;   // Enable I2C0 clock
	SIM->SCGC5 |= 0x800;  // Enable clock port C
	I2C0->C1 = 0x00;      // Disable I2C0 peripheral to configure

	// Need to reach a frequency close to 100 khz
	I2C0->F = (I2C_F_MULT(0x04) | I2C_F_ICR(0x00));

	I2C0->C1 |= 0X80;                // Enable I2C module
	PORTC->PCR[8] = 0x0600 | 0x03;   // Enable SDA for this pin and enable pullup
	PORTC->PCR[9] = 0x0600 | 0x03;   // Enable SCL for this pin and enable pullup
}

void SteppersInit(void){
	// Configure motor X pins
	uint32_t stp_pin = 0;
	PORT_Type* stp_port = PORTC;
	uint32_t dir_pin = 7;
	PORT_Type* dir_port = PORTC;
	uint32_t enable_pin = 3;
	PORT_Type* enable_port = PORTC;
	// Create motor instance (step pin = C7, dir pin = C0)
	stpX = CreateStepper(stp_pin, stp_port, dir_pin, dir_port,
								 enable_pin, enable_port);
	// Configure motor Y pins
	stp_pin = 5;
	stp_port = PORTC;
	dir_pin = 4;
	dir_port = PORTC;
	enable_pin = 6;
	enable_port = PORTC;
	// Create instance
	stpY = CreateStepper(stp_pin, stp_port, dir_pin, dir_port,
									 enable_pin, enable_port);
	// Configure motor Z pins
	stp_pin = 12;
	stp_port = PORTA;
	dir_pin = 4;
	dir_port = PORTD;
	enable_pin = 4;
	enable_port = PORTA;
	// Create instance
	stpZ = CreateStepper(stp_pin, stp_port, dir_pin, dir_port,
									 enable_pin, enable_port);
	// Init steppers
	StepperInit(&stpX);
	StepperInit(&stpY);
	StepperInit(&stpZ);
}

void ErrorHandler(void){
	RGB_Off();  // Turn off RGB LED
	RedOn();    // Turn on red light
	while(1){}  // Infinite loop

}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/PCB Inspector/Required Libraries/Functions/Stepper.c

#include "Headers/Stepper.h"

static GPIO_Type* IdentifyGPIO(PORT_Type *);
static uint32_t ToBinaryGPIO(uint32_t);

Stepper CreateStepper(uint32_t stp_pin, PORT_Type* stp_port, uint32_t dir_pin,
					 PORT_Type* dir_port, uint32_t enable_pin, PORT_Type *enable_port){
	Stepper stepper;
	stepper.stp_pin = stp_pin;
	stepper.stp_port = stp_port;
	stepper.dir_pin = dir_pin;
	stepper.dir_port = dir_port;
	stepper.enable_pin = enable_pin;
	stepper.enable_port = enable_port;
	stepper.run = 1;
	return stepper;
}

void SetStepperSettings(Stepper* stepper, uint8_t dir,
						uint32_t step_delay, uint16_t steps_rev){
	stepper->direction = dir;
	stepper->step_delay = step_delay;
	stepper->steps_rev = steps_rev;
}

void SetStepperDirection(Stepper* stepper, uint8_t dir){
	stepper->direction = dir;
	GPIO_Type *dir_gpio = IdentifyGPIO(stepper->dir_port);
	if(dir == CLOCKWISE)
		SetPinHigh(dir_gpio, ToBinaryGPIO(stepper->dir_pin));
	else
		SetPinLow(dir_gpio, ToBinaryGPIO(stepper->dir_pin));
}

void SetStepperDelay(Stepper *stepper, uint32_t delay_micros){
	stepper->step_delay = delay_micros;
}

void StepperInit(Stepper *step_struct){
	// Configure GPIOs
	GPIO_Configure(step_struct->stp_port, step_struct->stp_pin);
	GPIO_Configure(step_struct->dir_port, step_struct->dir_pin);
	GPIO_Configure(step_struct->enable_port, step_struct->enable_pin);
	// Set default between steps delay (in microseconds)
	SetStepperDelay(step_struct, 4000);
	// Set default direction clockwise
	SetStepperDirection(step_struct, CLOCKWISE);
}

// Put this function inside a LOOP to move constantly (note that systicks should be less than millis)
void RunStepper(Stepper* stepper){
	GPIO_Type* stp_gpio = IdentifyGPIO(stepper->stp_port);

	if(stepper->run == 1){
		SetPinHigh(stp_gpio, ToBinaryGPIO(stepper->stp_pin));
		delayUs(stepper->step_delay);
		SetPinLow(stp_gpio, ToBinaryGPIO(stepper->stp_pin));
		delayUs(stepper->step_delay);
	}else{
		SetPinLow(stp_gpio, ToBinaryGPIO(stepper->stp_pin));
	}
}

/**
 * @brief This function sets the velocity of the motor given a resolution
 * Half of the resolution is set for counterclockwise and the rest for clockwise
 * */
void SetStepperVelocity(Stepper* stepper, uint8_t velocity){
	if(velocity >= (SPEED_RESOLUTION >> 1))
		SetStepperDirection(stepper, CLOCKWISE);
	else
		SetStepperDirection(stepper, COUNTERCLOCKWISE);
	velocity = (velocity >= (SPEED_RESOLUTION >> 1)? velocity - (SPEED_RESOLUTION >> 1) : velocity << 1);
	uint16_t delay_us = (MIN_US_DELAY * SPEED_RESOLUTION) / velocity;
	if(delay_us < MAX_US_DELAY){
		stepper->run = 1;
		SetStepperDelay(stepper, delay_us);
	}
	else{
		stepper->run = 0;
	}
}

/**
 * @brief A function to move certain number of millimeters in the current direction
 * */
void MoveMillimeters(Stepper *stepper, uint16_t millimeters){
	uint16_t counter = 0;  uint16_t desired_count = (millimeters / STEP_SIZE); // Check if it can handle float div
	stepper->run = 1;
	while(counter < desired_count){
		for(uint8_t i=0; i < stepper->steps_rev; i++){   // One spin
			RunStepper(stepper);
		}
	}
	stepper->run = 0;
	RunStepper(stepper);   // Turn stepper off
}

void StepperOff(Stepper* stepper){
	GPIO_Type* stp_gpio = IdentifyGPIO(stepper->stp_port);
	SetPinLow(stp_gpio, ToBinaryGPIO(stepper->stp_pin));
}

void SetPinHigh(GPIO_Type *port, uint32_t pin){
	port->PDOR |= pin;
}

void SetPinLow(GPIO_Type *port, uint32_t pin){
	port->PDOR &= ~pin;
}

static GPIO_Type* IdentifyGPIO(PORT_Type *port){
	if(port == PORTA){
		return GPIOA;
	}else if(port == PORTB){
		return GPIOB;
	}else if(port == PORTC){
		return GPIOC;
	}else if(port == PORTD){
		return GPIOD;
	}else{
		return GPIOE;
	}
}

void GPIO_Configure(PORT_Type *port, uint32_t pin){
	PortConfigure(port);
	port->PCR[pin] = 0x100;

	if(port == PORTA){
		GPIOA->PDDR |= ToBinaryGPIO(pin);    // Set as output
	}else if (port == PORTB){
		GPIOB->PDDR |= ToBinaryGPIO(pin);
	}else if (port == PORTC){
		GPIOC->PDDR |= ToBinaryGPIO(pin);
	}else if (port == PORTD){
		GPIOD->PDDR |= ToBinaryGPIO(pin);
	}else{
		GPIOE->PDDR |= ToBinaryGPIO(pin);
	}
}

void PortConfigure(PORT_Type *port){
	if(port == PORTA){
		SIM->SCGC5 |= 0x200;   // Enable clock port A
	}else if (port == PORTB){
		SIM->SCGC5 |= 0x400;   // Enable clock port B
	}else if (port == PORTC){
		SIM->SCGC5 |= 0x800;   // Enable clock port C
	}else if (port == PORTD){
		SIM->SCGC5 |= 0x1000;  // Enable clock port D
	}else{
		SIM->SCGC5 |= 0x2000;  // Enable clock port E
	}
}

static uint32_t ToBinaryGPIO(uint32_t num){
	return (1 << num);
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/PCB Inspector/Required Libraries/Functions/Clocks.c

#include "Headers/Clocks.h"

// Variables
static uint32_t freq;
static uint64_t systicks;
static uint32_t time_delay;
uint16_t conv_factor;

// Configure the Multipurpose Clock Generator (MCG) - currently to 48 Mhz, bus clock to 8 Mhz
void MCG_Config(void){
	// MCG_C1: CLKS (bit 7-6) = 00
	MCG->C1 |= MCG_C1_CLKS(0);  // Select PLL/FLL as clock source
	// MCG_C1 : IREFS = 1
	MCG->C1 |= MCG_C1_IREFS(1);     // Select internal clock as FLL source
	//MCG->C1 |= MCG_C1_IRCLKEN(1);
	MCG->C2 |= MCG_C2_IRCS(0); 		// Enable slow internal clock (32 khz)

	MCG->C4 = MCG_C4_DMX32(1) | MCG_C4_DRST_DRS(1);  // Set to 48 Mhz FLL
	SIM->CLKDIV1 |= SIM_CLKDIV1_OUTDIV4(1);     // 48 Mhz/6 = 8Mhz bus clock

	SystemCoreClockUpdate(); // Update system core clock value
}

// Systick init
void ClkInit(uint8_t clock_freq){
	freq = MapFrequency(clock_freq);
	SetConvFactor(clock_freq);
	ClkFreqConfig(freq);
}

// Systick init with interrupt
void ClkInitIt(uint8_t clock_freq){
	freq = MapFrequency(clock_freq);
	SetConvFactor(clock_freq);
	ClkFreqConfig(freq);
	SysTick->CTRL |= 0x02;       // Enable Systick interrupt
}

// Map system core clock ticks to desired frequency
uint32_t MapFrequency(uint8_t desired_freq){
	switch(desired_freq){
	case CLK_MILLIS:
		return (SystemCoreClock/1000) - 1;
	case CLK_HUNDRED_MICROS:
		return (SystemCoreClock/10000) - 1;
	case CLK_TENS_MICROS:
		return (SystemCoreClock/100000) - 1;
	case CLK_MICROS:
		return (SystemCoreClock/1000000) - 1;
	default:
		return (SystemCoreClock/100000) - 1;    // Tens micros as default case
	}
}

// Conversion factors to use milliseconds as reference for timing
void SetConvFactor(uint8_t freq){
	if(freq == CLK_MICROS)
		conv_factor = MILLIS2MICROS;
	else if(freq == CLK_HUNDRED_MICROS)
		conv_factor = MILLIS2HUNDRED_MICROS;
	else if (freq == CLK_TENS_MICROS)
		conv_factor = MILLIS2TENS_MICROS;
	else
		conv_factor = 1;
}

// Systick callback
void SysTick_Handler(void){
	time_delay = (time_delay > 0)? time_delay-1 : 0;
	systicks++;
}

// Configure the frequency of the systick clock
void ClkFreqConfig(uint32_t clock_freq){
	SysTick->LOAD = clock_freq;  // Remember default systick freq for KL25Z is 21.9 Mhz
	SysTick->CTRL |= 0x05;     	 // Enable timer and set sysclk as source clock
}

// Get current systicks
uint64_t *GetSysTicks(void){
	return &systicks;
}

// Set delay ticks in current timing unit
void SetDelayTicks(uint32_t delay_ticks){
	time_delay = delay_ticks;
}

///// DELAY FUNCTIONS /////
void delayMs(uint32_t delay){
	// Manage different conversions according to time unit
	if(freq == CLK_MILLIS)
		time_delay = delay;
	else if (freq == CLK_HUNDRED_MICROS)
		time_delay = delay * 10;
	else if (freq == CLK_TENS_MICROS)
		time_delay = delay * 100;
	else
		time_delay = delay << 10;   // Multiplication cannot catch up at high speeds

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}

void delayUs(uint32_t delay){
	if (freq == CLK_MILLIS)
		time_delay = delay >> 10;
	else if(freq == CLK_HUNDRED_MICROS)
		time_delay = delay / 100;
	else if(freq == CLK_TENS_MICROS)
		time_delay = delay / 10;
	else
		time_delay = delay;

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/PCB Inspector/Required Libraries/Functions/RGB.c

#include "Headers/Rgb.h"

// Init RGB LED
void RGB_Init(void){
	// LED config
	SIM->SCGC5 |= 0x400;   // Enable clock port B
	SIM->SCGC5 |= 0x1000;  // Enable clock port D

	// Set pins as GPIOS
	PORTB->PCR[19] = 0x100;
	PORTB->PCR[18] = 0x100;
	PORTD->PCR[1] = 0x100;

	GPIOB->PDDR |= GREEN; // Enable (bit) pin 19 from GPIOB as output (Green)
	GPIOD->PDDR |= BLUE;  // Enable (bit) pin 1 from GPIOD as output (Blue)
	GPIOB->PDDR |= RED;   // Enable (bit) pin 18 from GPIOB as output (Red)

	RGB_Off();   // Set RGB Off after init
}

// Turn on LED
void LED_On(GPIO_Type *port, uint32_t pin){
	port->PDOR &= ~pin;
}

// Turn off LED
void LED_Off(GPIO_Type *port, uint32_t pin){
	port->PDOR |= pin;
}

// Toggle the LED
void LED_Toggle(GPIO_Type *port, uint32_t pin){
	port->PTOR |= pin;
}

// Set all LEDs On
void RGB_On(void){
	LED_On(GREEN_LED_PORT, GREEN);
	LED_On(BLUE_LED_PORT, BLUE);
	LED_On(RED_LED_PORT, RED);
}

// Set all LEDs Off
void RGB_Off(void){
	LED_Off(GREEN_LED_PORT, GREEN);
	LED_Off(BLUE_LED_PORT, BLUE);
	LED_Off(RED_LED_PORT, RED);
}

///////// Colors /////////
void GreenOn(void){
	LED_On(GREEN_LED_PORT, GREEN);
}

void BlueOn(void){
	LED_On(BLUE_LED_PORT, BLUE);
}

void RedOn(void){
	LED_On(RED_LED_PORT, RED);
}

void WhiteOn(void){
	RGB_On();
}

void YellowOn(void){
	GreenOn();
	RedOn();
}

void PurpleOn(void){
	RedOn();
	BlueOn();
}

///////// Colors Off /////////
void GreenOff(void){
	LED_Off(GREEN_LED_PORT, GREEN);
}

void BlueOff(void){
	LED_Off(BLUE_LED_PORT, BLUE);
}

void RedOff(void){
	LED_Off(RED_LED_PORT, RED);
}

void WhiteOff(void){
	RGB_Off();
}

void YellowOff(void){
	GreenOff();
	RedOff();
}

void PurpleOff(void){
	RedOff();
	BlueOff();
}

///////// Colors Toggle  /////////
void GreenToggle(void){
	LED_Toggle(GREEN_LED_PORT, GREEN);
}

void BlueToggle(void){
	LED_Toggle(BLUE_LED_PORT, BLUE);
}

void RedToggle(void){
	LED_Toggle(RED_LED_PORT, RED);
}

void WhiteToggle(void){
	GreenToggle();
	BlueToggle();
	RedToggle();
}

void YellowToggle(void){
	GreenToggle();
	RedToggle();
}
void PurpleToggle(void){
	BlueToggle();
	RedToggle();
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/PCB Inspector/Required Libraries/Functions/UART.c

#include "Headers/UART.h"

// NOTE: UART0 is clocked directly from MCGFLLCLK unlike other peripherals
// which are clocked by the bus/flash clock

char *tx_buffer;

void SetTX_Buffer(char *buff){
	tx_buffer = buff;
}

void UART_Config(void){
	// Clocks
	SIM->SOPT2 |= (1 << 26);   // Specify clock  --> Uses the same as clock core (48 Mhz currently)
	SIM->SCGC4 |= 0x400;	   // Enable clock for UART0
	// Baud Rate
	UART0->BDH = 0x01;
	UART0->BDL = 0x38;         // Baud Rate = 9600
	//UART0->BDH = 0x01;       // 9600 for 72Mhz clock
	//UART0->BDL = 0xD6;
	// Configurations
	UART0->C1 |= 0x80;  	   // UART RX and TX in different pins (normal operation)
	UART0->C2 |= 0x08;		   // Enable UART Transmitter
	UART0->C4 |= 0x0F;		   // Enable oversampling to 16
	// Ports
	SIM->SCGC5 |= 0x200;       // Enable clock for PORTA
	PORTA->PCR[2] = 0x0200;    // Make PTA2 UART0 Pin
}

void UART_Send(void){
	for(uint8_t i=0; i < strlen(tx_buffer); i++){
		UART0->D = tx_buffer[i];
	}
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/PCB_InspectorRTOS/CircuitVision.c

#include "CircuitVision.h"

// Task handlers
TaskHandle_t BlinkBlue_Handle = NULL;
TaskHandle_t ConsoleWriteHandle = NULL;
TaskHandle_t MenuDisplay_Handle = NULL;
TaskHandle_t ADC_Sampling_Handle = NULL;
TaskHandle_t ManualDisplay_Handle = NULL;
TaskHandle_t ManualMode_Handle = NULL;
// Queues
QueueHandle_t xJoystickQueue;
QueueHandle_t yJoystickQueue;

// Global variables
char tx_buff[UART_BUFFER_SIZE];
uint8_t operation_mode = MANUAL;

//////////////////// TASK FUNCTIONS ////////////////////
// Manual Mode
void ManualMode(void *pvParameters){
	uint16_t xJoystick, yJoystick;
	uint8_t xMotorDirection, yMotorDirection;
	int xMotorPercentage, yMotorPercentage;

	for(;;){
		// Only operate this task if mode is manual
		if(operation_mode == MANUAL){
			// Receive X axis Joystick
			if(xQueueReceive(xJoystickQueue, &xJoystick, 0) == pdPASS){
				// Convert to a range 0 - 100 in each direction
				if(xJoystick <= 48700){
					xMotorPercentage = (xJoystick - 48800) * (-1) / 482;
					StepperX_Direction(COUNTERCLOCKWISE);
				}else{
					xMotorPercentage = (xJoystick - 48800) / 169;
					StepperX_Direction(CLOCKWISE);
				}
			}
			// Receive Y axis Joystick
			if(xQueueReceive(yJoystickQueue, &yJoystick, 0) == pdPASS){
				yMotorPercentage = (yJoystick - 40400) * (-1) / 402;
			}
			// RUN MOTORS with calculated values
			snprintf(tx_buff, sizeof(tx_buff), "Motors x: %d, y: %d\n", xMotorPercentage, yJoystick);
			StepperX_RunPercentage(xMotorPercentage);

		}else{
			// If operation mode is not manual suspend this task
			vTaskSuspend(NULL);
		}

		vTaskDelay(pdMS_TO_TICKS(100));
	}
}

// ADC Sampling
void ADC_Sampling(void *pvParameters) {
	// ADC results
	uint16_t adc_result, adc_result2;
    // Start ADC sampling in channel 0
    ADC0->SC1[0] = 0;
    for (;;) {
    	// Handle sampling in ADC 0 channel 0
    	 if (ADC0->SC1[0] & ADC_SC1_COCO_MASK) {
    		 adc_result = ADC0->R[0];
    		 // Start ADC conversion in channel 4
    		 ADC0->SC1[0] = 0x04;
    	 }
    	 vTaskDelay(pdMS_TO_TICKS(1));
    	 // Handle sampling in ADC 0 channel 0
    	 if (ADC0->SC1[0] & ADC_SC1_COCO_MASK) {
			 adc_result2 = ADC0->R[0];
			 // Start ADC conversion in channel 0
			 ADC0->SC1[0] = 0;
		 }
    	 //snprintf(tx_buff, sizeof(tx_buff), "ADC result: %d, %d\n", adc_result, adc_result2);
    	 // Send data to queues
    	 xQueueSendToBack(xJoystickQueue, &adc_result, 1);
    	 xQueueSendToBack(yJoystickQueue, &adc_result2, 1);
         // Delay
         vTaskDelay(pdMS_TO_TICKS(50));
    }
}

// Display Manual Mode
void ManualDisplay(void *pvParameters){
	// Print content and suspend itself
	for (;;){
		if(operation_mode == MANUAL){
			LCD_print_1st_line("  Manual Mode");
			LCD_print_2nd_line("             ");
			vTaskDelay(pdMS_TO_TICKS(2000));
			LCD_print_1st_line("  Use Joystick");
			vTaskResume(ManualMode_Handle);
			vTaskSuspend(NULL);;
		}
	}
}

// Display in LCD Menu
void InspectorMenuDisplay(void *pvParameters){
	for(;;){
		LCD_print_1st_line(" Circuit Vision");
		LCD_print_2nd_line("      MENU");
		vTaskDelay(pdMS_TO_TICKS(1500));
		//LCD_clear();
		LCD_print_1st_line("    Press key");
		LCD_print_2nd_line("              ");
		vTaskDelay(pdMS_TO_TICKS(1500));
		LCD_print_1st_line("A-Automatic Mode");
		LCD_print_2nd_line("B-Manual Mode");
		vTaskDelay(pdMS_TO_TICKS(3000));
		vTaskResume(ManualDisplay_Handle);
		vTaskSuspend(NULL);
	}
}

// Write to console through UART
void ConsoleWrite(void *pvParameters){
	for(;;){
		UART_Send();
		vTaskDelay(pdMS_TO_TICKS(500));
	}
}

// Blink Blue LED
void BlinkBlue(void *pvParameters){
	for(;;){
		BlueToggle();
		vTaskDelay(pdMS_TO_TICKS(1000));
	}
}

////////////////////////////////////////////////////////

// Tasks Creation
void CreateTasks(void){
	// Queues
	xJoystickQueue = xQueueCreate(1, sizeof(uint16_t));
	yJoystickQueue = xQueueCreate(1, sizeof(uint16_t));

	// MODES
	xTaskCreate(ManualMode, "ManualModeTask", 512, NULL,
								tskIDLE_PRIORITY + 1, &ManualMode_Handle);
	vTaskSuspend(ManualMode_Handle);

	// Manual Mode Display
	xTaskCreate(ManualDisplay, "ManualDisplayTask", 100, NULL,
								tskIDLE_PRIORITY + 1, &ManualDisplay_Handle);
	vTaskSuspend(ManualDisplay_Handle);

	// Main Menu (not doing anything)
	xTaskCreate(InspectorMenuDisplay, "MenuDisplayTask", 64, NULL,
							    tskIDLE_PRIORITY + 1, &MenuDisplay_Handle);
	// UART Task
	xTaskCreate(ConsoleWrite, "ConsoleWriteTask", 16, NULL,
								tskIDLE_PRIORITY + 2, &ConsoleWriteHandle);

	// ADC Processing task
	xTaskCreate(ADC_Sampling, "ADC_SamplingTask", 150, NULL,
							    tskIDLE_PRIORITY + 2, &ADC_Sampling_Handle);

	// Blink blue LED task
	xTaskCreate(BlinkBlue, "BlinkBlueTask", 8, NULL,
								tskIDLE_PRIORITY + 1, &BlinkBlue_Handle);
	//vTaskSuspend(BlinkBlue_Handle);
}

////////////////// BARE METAL CONFIG //////////////////


//////////////////// MAIN FUNCTION ////////////////////
int main(void) {
	////////// Configurations //////////
	RGB_Init();
	UART0_Config(interrupt_rx, baud4);
	ADC_Config();
	SteppersInit();
	// LCD I2C Init
	LCD_Init_Config(I2C_HANDLE);
	// UART set buffers
	SetTX_Buffer(tx_buff, UART_BUFFER_SIZE);
	//////////// FreeRTOS ////////////
	// Tasks creation
	CreateTasks();
	// Give program control to scheduler
	vTaskStartScheduler();

	// Should never reach here
	for(;;);
    return 0 ;
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Function Generator/FuncGen.c

#include "main.h"
#include "math.h"

#define MAX_RESOLUTION 256

// Functions
static void DAC_Init(void);
static void UART_Config(void);
static void SineGenerate(uint64_t);
static void SquareGenerate(uint64_t);
static void TriangularGenerate(uint64_t);
static uint64_t CalculateTicks(uint64_t);

// Initial values for function generation
uint16_t value_index = 0;
uint16_t resolution = 0;
uint8_t mode = SQUARE;
uint64_t update_ticks = 0;
uint64_t frequency = 50;   // Frequency in hertz
uint8_t updated = 0;  // Used as a boolean

// Time aux
uint64_t blink_aux = 0, wave_aux = 0, print_aux = 0;

// UART buffer
char uart_rx[50];
char uart_tx[100];
uint8_t uart_rx_index = 0;
uint64_t last_rx_aux = 0;

// Systick pointer
const uint64_t *systicks;

// Values for a sine wave
uint16_t lookupTable[256];

// LCD buffer
char lcd_buff[16];

int main(void) {
    // Config functions
    ClkInitIt(CLK_TENS_MICROS);
    // Init RGB led
    RGB_Init();
    // Init DAC
    DAC_Init();
    // Init UART
    UART_Config();
    // LCD i2c init
    LCD_init();
    // Set systick pointer
    systicks = GetSysTicks();

    SquareGenerate(frequency);
    //SquareGenerate(frequency);
    //TriangularGenerate(frequency);

    // Main loop
    while (1) {
    	// If something should be updated
    	if(updated == 1){
    		SquareGenerate(frequency);
    		updated = 0;
    	}

        // Blink led
        if (*systicks - blink_aux >= TIME_TO_BLINK_MS * conv_factor) {
            BlueToggle();
            blink_aux = *systicks;
        }

        // Update waveform
        if(*systicks - wave_aux >= update_ticks){
        	value_index = (value_index >= resolution - 1)? 0 : value_index+1;
        	DAC0->DAT[0].DATL = lookupTable[value_index] & 0xff;   /* write low byte */
        	DAC0->DAT[0].DATH = (lookupTable[value_index] >> 8) & 0x0f; /* write high byte */
        	wave_aux = *systicks;
        }
    }
    return 0;
}

// Function to fill lookup table with sine values
static void SineGenerate(uint64_t freq){
	const float M_PI = 3.1415926535897;
	uint64_t period_ticks = CalculateTicks(freq);
	update_ticks = period_ticks / MAX_RESOLUTION;
	resolution = (update_ticks == 0)? period_ticks : MAX_RESOLUTION;
	float fRadians = ((2 * M_PI) / resolution);
	for (uint16_t i = 0; i < resolution; i++) {
		lookupTable[i] = 2047 * (sinf(fRadians * i) + 1);
	}
}

// Function to fill lookup table with square values
static void SquareGenerate(uint64_t freq){
	uint64_t period_ticks = CalculateTicks(freq);
	update_ticks = period_ticks / MAX_RESOLUTION;
	resolution = (update_ticks == 0)? period_ticks : MAX_RESOLUTION;

	for (uint16_t i = 0; i < resolution; i++) {
		if(i >= resolution / 2){
			lookupTable[i] = 4095;
		}else{
			lookupTable[i] = 0;
		}
	}
}

// Function to fill lookup table with triangular values
static void TriangularGenerate(uint64_t freq){
	uint64_t period_ticks = CalculateTicks(freq);
	update_ticks = period_ticks / MAX_RESOLUTION;
	resolution = (update_ticks == 0)? period_ticks : MAX_RESOLUTION;
	double slope_delta = 4095.0 / ((double) MAX_RESOLUTION / 2.0);

	for (uint16_t i = 0; i < resolution; i++) {
		if(i <= resolution / 2){
			lookupTable[i] = (i == 0)? 0 : lookupTable[i-1] + (uint8_t)slope_delta;
		}else{
			lookupTable[i] = lookupTable[i-1] - (uint8_t)slope_delta;
			if(lookupTable[i] < 0){lookupTable[i] = 0;}
		}
	}
}

// Function to calculate needed ticks in one period to achieve desired frequency
static uint64_t CalculateTicks(uint64_t freq){
	 if (freq == 0) {
		return 0; // Handle the case where frequency is zero
	}
	double period = 1.0 / (double)freq;
	uint64_t ticks = (uint64_t)(period * 100000.0); // Assuming you are using TENS_MICROS as timebase
	return ticks;
}

// DAC configuring
static void DAC_Init(void) {
    SIM->SCGC6 |= SIM_SCGC6_DAC0_MASK;
    DAC0->C1 = 0; /* disable the use of buffer */
    DAC0->C0 = DAC_C0_DACEN_MASK | DAC_C0_DACRFS_MASK; /* enable DAC and use VDDA as reference */
}

static void UART_Config(void) {
    // Clocks
    SIM->SCGC4 |= SIM_SCGC4_UART0_MASK; // Enable clock for UART0
    SIM->SOPT2 |= SIM_SOPT2_UART0SRC(1); // Specify clock

    // Baud Rate
	UART0->BDH = 0x00;
	UART0->BDL = 0x0C;         // Baud Rate = 115200

    // Configurations
    UART0->C1 = 0x00; // 8-bit data, no parity
    UART0->C2 |= UART_C2_TE_MASK | UART_C2_RE_MASK; // Enable transmitter and receiver
    UART0->C4 |= 0x0F;	 // Enable oversampling to 16

    // Ports
    SIM->SCGC5 |= SIM_SCGC5_PORTA_MASK; // Enable clock for PORTA
    PORTA->PCR[1] = PORT_PCR_MUX(2); // Set PTA1 to UART0_RX
    PORTA->PCR[2] = PORT_PCR_MUX(2); // Set PTA2 to UART0_TX

    // Enable interrupt mode for receiver
    UART0->C2 |= (1 << 5);   // Enable receive interrupt
    NVIC_EnableIRQ(UART0_IRQn);   // Enable interrupt with NVIC
}

// Callback for UART0 interrupt (An event related to UART0 has happened)
void UART0_IRQHandler(void) {
    while (UART0->S1 & UART_S1_RDRF_MASK) {
        char c = UART0->D;
        if (uart_rx_index < sizeof(uart_rx) - 1) {     // Ensure there's space in the buffer
            if (c == ' ') {
                uart_rx[uart_rx_index] = '\0';  // Null-terminate the string
                updated = 1;
                frequency = strtoull(uart_rx, NULL, 10);
                uart_rx_index = 0;  // Reset buffer index
            } else {
                uart_rx[uart_rx_index++] = c;
            }
        } else {
            uart_rx_index = 0;
            uart_rx[0] = '\0';
        }
    }
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Function Generator/Requirements/Clocks.c

#include "Headers/Clocks.h"

// Variables
static uint8_t freq_index;
static uint32_t freq;
static uint64_t systicks;
static uint32_t time_delay;
uint16_t conv_factor;

// Configure the Multipurpose Clock Generator (MCG) - currently to 48 Mhz, bus clock to 8 Mhz
void MCG_Config(void){
	// MCG_C1: CLKS (bit 7-6) = 00
	MCG->C1 |= MCG_C1_CLKS(0);  // Select PLL/FLL as clock source
	// MCG_C1 : IREFS = 1
	MCG->C1 |= MCG_C1_IREFS(1);     // Select internal clock as FLL source
	//MCG->C1 |= MCG_C1_IRCLKEN(1);
	MCG->C2 |= MCG_C2_IRCS(0); 		// Enable slow internal clock (32 khz)

	MCG->C4 = MCG_C4_DMX32(1) | MCG_C4_DRST_DRS(1);  // Set to 48 Mhz FLL
	SIM->CLKDIV1 |= SIM_CLKDIV1_OUTDIV4(1);     // 48 Mhz/6 = 8Mhz bus clock

	SystemCoreClockUpdate(); // Update system core clock value
}

// Systick init
void ClkInit(uint8_t clock_freq){
	SystemCoreClockUpdate();
	freq_index = clock_freq;
	freq = MapFrequency(clock_freq);
	SetConvFactor(clock_freq);
	ClkFreqConfig(freq);
}

// Systick init with interrupt
void ClkInitIt(uint8_t clock_freq){
	SystemCoreClockUpdate();
	freq_index = clock_freq;
	freq = MapFrequency(clock_freq);
	SetConvFactor(clock_freq);
	ClkFreqConfig(freq);
	SysTick->CTRL |= 0x02;       // Enable Systick interrupt
}

// Map system core clock ticks to desired frequency
uint32_t MapFrequency(uint8_t desired_freq){
	switch(desired_freq){
	case CLK_MILLIS:
		return (SystemCoreClock/1000) - 1;
	case CLK_HUNDRED_MICROS:
		return (SystemCoreClock/10000) - 1;
	case CLK_TENS_MICROS:
		return (SystemCoreClock/100000) - 1;
	case CLK_MICROS:
		return (SystemCoreClock/1000000) - 1;
	default:
		return (SystemCoreClock/100000) - 1;    // Tens micros as default case
	}
}

// Conversion factors to use milliseconds as reference for timing
void SetConvFactor(uint8_t freq){
	if(freq == CLK_MICROS)
		conv_factor = MILLIS2MICROS;
	else if(freq == CLK_HUNDRED_MICROS)
		conv_factor = MILLIS2HUNDRED_MICROS;
	else if (freq == CLK_TENS_MICROS)
		conv_factor = MILLIS2TENS_MICROS;
	else
		conv_factor = 1;
}

// Systick callback
void SysTick_Handler(void){
	time_delay = (time_delay > 0)? time_delay-1 : 0;
	systicks++;
}

// Configure the frequency of the systick clock
void ClkFreqConfig(uint32_t clock_freq){
	SysTick->LOAD = clock_freq;  // Remember default systick freq for KL25Z is 21.9 Mhz
	SysTick->CTRL |= 0x05;     	 // Enable timer and set sysclk as source clock
}

// Get current systicks
uint64_t *GetSysTicks(void){
	return &systicks;
}

// Set delay ticks in current timing unit
void SetDelayTicks(uint32_t delay_ticks){
	time_delay = delay_ticks;
}

///// DELAY FUNCTIONS /////
void delayMs(uint32_t delay){
	// Manage different conversions according to time unit
	if(freq_index == CLK_MILLIS)
		time_delay = delay;
	else if (freq_index == CLK_HUNDRED_MICROS)
		time_delay = delay * 10;
	else if (freq_index == CLK_TENS_MICROS)
		time_delay = delay * 100;
	else
		time_delay = delay << 10;   // Multiplication cannot catch up at high speeds

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}

void delayUs(uint32_t delay){
	if (freq_index == CLK_MILLIS)
		time_delay = delay >> 10;
	else if(freq_index == CLK_HUNDRED_MICROS)
		time_delay = delay / 100;
	else if(freq_index == CLK_TENS_MICROS)
		time_delay = delay / 10;
	else
		time_delay = delay;

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/ADC/Joystick/Joystick.c

#include "main.h"

// Config functions
static void ClockConfig(void);
static void UART_Config(void);
static void ADC_Config(void);

volatile uint64_t millis = 0;
uint64_t blink_aux = 0, print_aux = 0, adc_aux = 0;

// UART buffer
char uart_c[50];
// ADC readings
uint16_t adc_res = 0, adc_res2 = 0;

int main(void){
	ClockConfig();
	UART_Config();
	ADC_Config();

	// Init RGB led
	RGB_Init();

	// Start ADC conversion in channel 0
	ADC0->SC1[0] = 0;

	// Main loop
	while(1){
		// Blink led
		if(millis - blink_aux >= TIME_TO_BLINK_MS){
			PurpleToggle();
			blink_aux = millis;
		}

		// Read ADC and clear flag
		if(millis - adc_aux >= TIME_TO_READ_ADC_MS){
			adc_aux = millis;

			while(!(ADC0->SC1[0] & 0x80)) {   // Wait for end of conversion flag
				if(millis - adc_aux >= ADC_TIMEOUT_MS){
					break;
				}
			}
			// Assign ADC result
			adc_res = ADC0->R[0];
			adc_aux = millis;

			// Start ADC conversion in channel 4
			ADC0->SC1[0] = 0x04;

			while(!(ADC0->SC1[0] & 0x80)) {   // Wait for end of conversion flag
				if(millis - adc_aux >= ADC_TIMEOUT_MS){
					break;
				}
			}
			// Store result
			adc_res2 = ADC0->R[0];
			adc_aux = millis;
			// Start ADC conversion in channel 0
			ADC0->SC1[0] = 0;
		}

		// Print in UART0
		if(millis - print_aux >= TIME_TO_PRINT_MS){
			// Assign values to the buffer
			snprintf(uart_c, sizeof(uart_c), "X: %d, Y: %d\n", adc_res, adc_res2);
			print_aux = millis;

			for(uint8_t i=0; i < strlen(uart_c); i++){
				UART0->D = uart_c[i];
				while(!(UART0->S1 & 0x40)){  // Wait for the TX buffer to be empty
					if(millis - print_aux >= UART_TIMEOUT_MS){
						break;
					}
				}
			}
			print_aux = millis;
		}
	}
	return 0;
}

// Systick callback
void SysTick_Handler(void){
	millis++;
}

// Configure ADC
void ADC_Config(void){
	SIM->SCGC5 |= 0x2000;       // Enable PORTE clock
	SIM->SCGC6 |= 0x8000000;    // ADC0 clock
	PORTE->PCR[20] = 0x000;     // Configure pin PORTE 20 as analog
	PORTE->PCR[21] = 0x000;     // Configure pin PORTE 21 as analog

	ADC0->SC2 &= ~0x40;      // Software trigger
	ADC0->CFG1 = 0x40 | 0x04 | 0x00 | 0x10;
}

void ClockConfig(void){
	// Systick clock frequency = 21 Mhz
	SysTick->LOAD = (SystemCoreClock / 1000) - 1;  // Remember default systick freq for KL25Z is 41.94 Mhz
	SysTick->CTRL |= 0x05;     	 // Enable timer and set sysclk as source clock
	SysTick->CTRL |= 0x02;       // Enable Systick interrupt
}

void UART_Config(void){
	// Clocks
	SIM->SCGC4 |= 0x400;	   // Enable clock for UART0
	SIM->SOPT2 |= 0x4000000;   // Specify clock
	// Baud Rate
	UART0->BDH = 0x00;
	UART0->BDL = 0x0C;         // Baud Rate = 115200
	// Configurations
	UART0->C1 |= 0x80;  	   // UART RX and TX in different pins (normal operation)
	UART0->C2 |= 0x08;		   // Enable UART Transmitter
	UART0->C4 |= 0x0F;		   // Enable oversampling to 16
	// Ports
	SIM->SCGC5 |= 0x200;       // Enable clock for PORTA
	PORTA->PCR[1] = 0x0200;    // Make PTA1 UART0 Pin
	PORTA->PCR[2] = 0x0200;    // Make PTA2 UART0 Pin
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/Builtin RGB/RGB.c

#include "Headers/Rgb.h"

// Init RGB LED
void RGB_Init(void){
	// LED config
	SIM->SCGC5 |= 0x400;   // Enable clock port B
	SIM->SCGC5 |= 0x1000;  // Enable clock port D

	// Set pins as GPIOS
	PORTB->PCR[19] = 0x100;
	PORTB->PCR[18] = 0x100;
	PORTD->PCR[1] = 0x100;

	GPIOB->PDDR |= GREEN; // Enable (bit) pin 19 from GPIOB as output (Green)
	GPIOD->PDDR |= BLUE;  // Enable (bit) pin 1 from GPIOD as output (Blue)
	GPIOB->PDDR |= RED;   // Enable (bit) pin 18 from GPIOB as output (Red)

	RGB_Off();   // Set RGB Off after init
}

// Turn on LED
void LED_On(GPIO_Type *port, uint32_t pin){
	port->PDOR &= ~pin;
}

// Turn off LED
void LED_Off(GPIO_Type *port, uint32_t pin){
	port->PDOR |= pin;
}

// Toggle the LED
void LED_Toggle(GPIO_Type *port, uint32_t pin){
	port->PTOR |= pin;
}

// Set all LEDs On
void RGB_On(void){
	LED_On(GREEN_LED_PORT, GREEN);
	LED_On(BLUE_LED_PORT, BLUE);
	LED_On(RED_LED_PORT, RED);
}

// Set all LEDs Off
void RGB_Off(void){
	LED_Off(GREEN_LED_PORT, GREEN);
	LED_Off(BLUE_LED_PORT, BLUE);
	LED_Off(RED_LED_PORT, RED);
}

///////// Colors /////////
void GreenOn(void){
	LED_On(GREEN_LED_PORT, GREEN);
}

void BlueOn(void){
	LED_On(BLUE_LED_PORT, BLUE);
}

void RedOn(void){
	LED_On(RED_LED_PORT, RED);
}

void WhiteOn(void){
	RGB_On();
}

void YellowOn(void){
	GreenOn();
	RedOn();
}

void PurpleOn(void){
	RedOn();
	BlueOn();
}

///////// Colors Off /////////
void GreenOff(void){
	LED_Off(GREEN_LED_PORT, GREEN);
}

void BlueOff(void){
	LED_Off(BLUE_LED_PORT, BLUE);
}

void RedOff(void){
	LED_Off(RED_LED_PORT, RED);
}

void WhiteOff(void){
	RGB_Off();
}

void YellowOff(void){
	GreenOff();
	RedOff();
}

void PurpleOff(void){
	RedOff();
	BlueOff();
}

///////// Colors Toggle  /////////
void GreenToggle(void){
	LED_Toggle(GREEN_LED_PORT, GREEN);
}

void BlueToggle(void){
	LED_Toggle(BLUE_LED_PORT, BLUE);
}

void RedToggle(void){
	LED_Toggle(RED_LED_PORT, RED);
}

void WhiteToggle(void){
	GreenToggle();
	BlueToggle();
	RedToggle();
}

void YellowToggle(void){
	GreenToggle();
	RedToggle();
}
void PurpleToggle(void){
	BlueToggle();
	RedToggle();
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/I2C_Display/i2cdisplay.c

/////////// Includes ///////////
#include "i2cdisplay.h"

/////////// Variables //////////
LCD_Config_Struct default_config = {
	.address = addr2,
	.rows = 2,
	.cols = 16,
	.backlight = LCD_BACKLIGHT
};

// I2C handler
I2C_Type *hi2c;
// Timing variable
volatile const uint64_t *millisecs;

/////////// Functions //////////
// Default Init
RETURN_TYPE LCD_DefaultInit(I2C_Type *handler, volatile const uint64_t *milliseconds){
	hi2c = handler;
	millisecs = milliseconds;
	return LCD_Init(&default_config);
}

// Custom Init
RETURN_TYPE LCD_Init(LCD_Config_Struct *configStruct){
	uint8_t status = 0;
	configStruct->displayFunction = LCD_4BITMODE | LCD_1LINE | LCD_5x8DOTS;

	if(configStruct->rows > 1)
		configStruct->displayFunction |= LCD_2LINE;

	// For the cases you want a 10 px high font
	if(configStruct->datasize != 0 && configStruct->rows == 1)
		configStruct->displayFunction |= LCD_5x10DOTS;

	// Small delay before sending commands
	delayMs(50);

	// Pull Rs and R/W to start sending commands
	status = I2C_WriteByte(configStruct->backlight, configStruct->address);
	if(status ==  1){return 1;}
	delayMs(800);

	// We start in 8bit mode, try to set 4bit mode
	status = Write4Bits((0x03 << 4), configStruct->address);
	if(status ==  1){return 1;}
	delayMs(10);

	// second try
	status = Write4Bits((0x03 << 4), configStruct->address);
	if(status ==  1){return 1;}
	delayMs(10); // wait min 4.1ms

	// third go!
	status = Write4Bits((0x03 << 4), configStruct->address);
	if(status ==  1){return 1;}
	delayMs(10);

	// finally, set to 4-bit interface
	status = Write4Bits((0x02 << 4) | configStruct->backlight, configStruct->address);
	if(status ==  1){return 1;}
	delayMs(10);

	// set # lines, font size, etc.
	status = Command(LCD_FUNCTIONSET | configStruct->displayFunction, configStruct->address);
	if(status ==  1){return 1;}
	delayMs(5);

	// Turn on the display with no cursor and no blinking (default)
	configStruct->displayControl = LCD_DISPLAYON | LCD_CURSOROFF | LCD_BLINKOFF;
	//Display();
	///delayMs(4);

	// Clear
	//Clear();
	delayMs(5);
	Backlight();

	// Initialize to default text direction
	//configStruct->displayMode = LCD_ENTRYLEFT | LCD_ENTRYSHIFTDECREMENT;
	// Set the entry mode
	//Command(LCD_ENTRYMODESET | configStruct->displayMode | configStruct->backlight, configStruct->address);
	// Home
	//Home();

	return NO_ERROR;
}

RETURN_TYPE Write4Bits(uint8_t value, uint16_t address){
	I2C_WriteByte(value | default_config.backlight, address);
	delayMs(10);
	return PulseEnable(value, address);
}

RETURN_TYPE PulseEnable(uint8_t data, uint16_t address){
	I2C_WriteByte((data | En) | default_config.backlight, address);
	delayMs(10);

	I2C_WriteByte((data & ~En) | default_config.backlight, address);
	delayMs(10);
	return NO_ERROR;
}

////// Mid level commands for sending data/commands //////
RETURN_TYPE Command(uint8_t value, uint16_t address){
	return Send(value, 0, address);
}

RETURN_TYPE Send(uint8_t value, uint8_t mode, uint16_t address){
	uint8_t highnib = (value & 0xf0) | mode;
	uint8_t lownib = ((value << 4) & 0xf0) | mode;
	Write4Bits(highnib, address);
	delayMs(10);
	return Write4Bits(lownib, address);
}

////// HIGH LEVEL COMMANDS! - For the User  //////
RETURN_TYPE Clear(void){
	Command(LCD_CLEARDISPLAY, default_config.address);  // Clear and set cursor position to 0
	delayMs(10);  // This command takes a long time!
	return NO_ERROR;
}

RETURN_TYPE Home(void){
	Command(LCD_RETURNHOME | default_config.backlight, default_config.address);
	delayMs(4);   // This command takes a long time!
	return NO_ERROR;
}

// Print the specified text into the display
RETURN_TYPE PrintStr(const char *text){
	uint8_t max_length = 16, index = 0;
	while(*text != '\0'){   // Wait for null terminated character
		I2C_WriteByte(*text, default_config.address);
		text++;
	}
}

RETURN_TYPE SetCursor(uint8_t col, uint8_t row){
	int row_offsets[] = { 0x00, 0x40, 0x14, 0x54 };
	if (row > default_config.rows) {
		row = default_config.rows - 1;    // we count rows starting w/0
	}
	return Command(LCD_SETDDRAMADDR | (col + row_offsets[row]) | default_config.backlight, default_config.address);
}

////// Display configuring functions //////
RETURN_TYPE Display(void){
	default_config.displayControl |= LCD_DISPLAYON;
	return Command(LCD_DISPLAYCONTROL | default_config.displayControl | default_config.backlight, default_config.address);
}

RETURN_TYPE NoDisplay(void){
	default_config.displayControl &= ~LCD_DISPLAYON;
	return Command(LCD_DISPLAYCONTROL | default_config.displayControl | default_config.backlight, default_config.address);
}

RETURN_TYPE Cursor(void){
	default_config.displayControl |= LCD_CURSORON;
	return Command(LCD_DISPLAYCONTROL | default_config.displayControl | default_config.backlight, default_config.address);
}

RETURN_TYPE NoCursor(void){
	default_config.displayControl &= ~LCD_CURSORON;
	return Command(LCD_DISPLAYCONTROL | default_config.displayControl | default_config.backlight, default_config.address);
}

RETURN_TYPE Blink(void){
	default_config.displayControl |= LCD_BLINKON;
	return Command(LCD_DISPLAYCONTROL | default_config.displayControl | default_config.backlight, default_config.address);
}

RETURN_TYPE NoBlink(void){
	default_config.displayControl &= ~LCD_BLINKON;
	return Command(LCD_DISPLAYCONTROL | default_config.displayControl | default_config.backlight, default_config.address);
}

RETURN_TYPE Backlight(void){
	default_config.backlight = LCD_BACKLIGHT;
	return I2C_WriteByte(0 | default_config.backlight, default_config.address);
}

RETURN_TYPE NoBacklight(void){
	default_config.backlight = LCD_NOBACKLIGHT;
	return I2C_WriteByte(0 | default_config.backlight, default_config.address);
}

// I2C Functionalities - this should go inside an i2c specific file
RETURN_TYPE I2C_WriteByte(uint8_t data, uint16_t address){
	uint64_t time_aux = *millisecs;

	data = data;

	// Wait until i2c bus is free
	time_aux = *millisecs;
	while(hi2c->S & 0x20){ 	  // While it is busy check timeout
		if(*millisecs - time_aux >= I2C_TIMEOUT_MS * conv_factor){
			return ERROR;
		}
	}

	// Send start bit
	hi2c->C1 |= 0x10;   // Transmitter on
	hi2c->C1 |= 0x20;   // Set as master mode
	delayUs(100);

	// Send address
	hi2c->D = address << 1;  // Set LSB to 0 which means write

	time_aux = *millisecs;
	while(!(hi2c->S & 0x20)){    // Wait for transfer completed
		if(*millisecs - time_aux >= I2C_TIMEOUT_MS * conv_factor){
			return ERROR;
		}
	}
	// Clear Interrupt Flag
	hi2c->S |= 0x02;
	// Read acknowledge bit
	if(hi2c->S & 0x01)
		return ERROR;     // NACK (No acknowledge detected)
	delayUs(100);

	// Send Data
	hi2c->D = data;
	while(!(hi2c->S & 0x20)){    // Wait for transfer completed
		if(*millisecs - time_aux >= I2C_TIMEOUT_MS * conv_factor){
			return ERROR;
		}
		time_aux = *millisecs;
	}

	// Clear Interrupt Flag
	hi2c->S |= 0x02;

	if(hi2c->S & 0x01)
		return ERROR;     // NACK (No acknowledge detected)
	delayUs(100);

	// End transmission
	hi2c->C1 &= ~0x30;
	delayUs(1000);
	return NO_ERROR;
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/I2C_Display/main.c

#include "main.h"

// Time aux
uint64_t blink_aux = 0, print_aux = 0, adc_aux = 0;
// Systick pointer
const uint64_t *systicks;

// UART buffer
char uart_c[50];
// ADC readings
uint16_t adc_res = 0, adc_res2 = 0;

int main(void){
	// Config functions
	ClkInitIt(CLK_MILLIS);
	UART_Config();
	ADC_Config();
	I2C_Config();
	// Init RGB led
	RGB_Init();
	// Set systick pointer
	systicks = GetSysTicks();

	GreenOn();
	delayMs(2000);
	GreenOff();

	// Init LCD
	LCD_DefaultInit(I2C0, systicks);

	// Start ADC conversion in channel 0
	ADC0->SC1[0] = 0;

	// Main loop
	while(1){
		// Blink led
		if(*systicks - blink_aux >= TIME_TO_BLINK_MS * conv_factor){
			PurpleToggle();
			blink_aux = *systicks;
		}

		// Read ADC and clear flag
		if(*systicks - adc_aux >= TIME_TO_READ_ADC_MS * conv_factor){
			adc_aux = *systicks;

			while(!(ADC0->SC1[0] & 0x80)) {   // Wait for end of conversion flag
				if(*systicks - adc_aux >= ADC_TIMEOUT_MS * conv_factor){
					break;
				}
			}
			// Assign ADC result
			adc_res = ADC0->R[0];
			adc_aux = *systicks;

			// Start ADC conversion in channel 4
			ADC0->SC1[0] = 0x04;

			while(!(ADC0->SC1[0] & 0x80)) {   // Wait for end of conversion flag
				if(*systicks - adc_aux >= ADC_TIMEOUT_MS * conv_factor){
					break;
				}
			}
			// Store result
			adc_res2 = ADC0->R[0];
			adc_aux = *systicks;
			// Start ADC conversion in channel 0
			ADC0->SC1[0] = 0;
		}

		// Print in UART0
		if(*systicks - print_aux >= TIME_TO_PRINT_MS * conv_factor){
			// Assign values to the buffer
			snprintf(uart_c, sizeof(uart_c), "X: %d, Y: %d\n", adc_res, adc_res2);
			print_aux = *systicks;

			for(uint8_t i=0; i < strlen(uart_c); i++){
				UART0->D = uart_c[i];
				while(!(UART0->S1 & 0x40)){  // Wait for the TX buffer to be empty
					if(*systicks - print_aux >= UART_TIMEOUT_MS * conv_factor){
						break;
					}
				}
			}
			print_aux = *systicks;
		}
	}
	return 0;
}

// Configure ADC
void ADC_Config(void){
	SIM->SCGC5 |= 0x2000;       // Enable PORTE clock
	SIM->SCGC6 |= 0x8000000;    // ADC0 clock
	PORTE->PCR[20] = 0x000;     // Configure pin PORTE 20 as analog
	PORTE->PCR[21] = 0x000;     // Configure pin PORTE 21 as analog

	ADC0->SC2 &= ~0x40;      // Software trigger
	ADC0->CFG1 = 0x40 | 0x04 | 0x00 | 0x10;
}

void UART_Config(void){
	// Clocks
	SIM->SCGC4 |= 0x400;	   // Enable clock for UART0
	SIM->SOPT2 |= 0x4000000;   // Specify clock
	// Baud Rate
	UART0->BDH = 0x00;
	UART0->BDL = 0x0C;         // Baud Rate = 115200
	// Configurations
	UART0->C1 |= 0x80;  	   // UART RX and TX in different pins (normal operation)
	UART0->C2 |= 0x08;		   // Enable UART Transmitter
	UART0->C4 |= 0x0F;		   // Enable oversampling to 16
	// Ports
	SIM->SCGC5 |= 0x200;       // Enable clock for PORTA
	PORTA->PCR[1] = 0x0200;    // Make PTA1 UART0 Pin
	PORTA->PCR[2] = 0x0200;    // Make PTA2 UART0 Pin
}

// Configure I2C
void I2C_Config(void){
	SIM->SCGC4 |= 0x40;   // Enable I2C0 clock
	SIM->SCGC5 |= 0x800;  // Enable clock port C
	I2C0->C1 = 0x00;      // Disable I2C0 peripheral to configure

	// Need to reach a frequency close to 100 khz
	// My bus clock value: 5,492,500 Hz
	I2C0->F = 0x18;

	I2C0->C1 |= 0X80;         // Enable I2C module
	PORTC->PCR[8] = 0x0600 | 0x03;   // Enable SDA for this pin and enable pullup
	PORTC->PCR[9] = 0x0600 | 0x03;   // Enable SCL for this pin and enable pullup
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/I2C_Display/Functions/clocks.c

#include "Headers/Clocks.h"

// Variables
static uint32_t freq;
static uint64_t systicks;
static uint32_t time_delay;
uint16_t conv_factor;

// Systick init
void ClkInit(uint32_t clock_freq){
	freq = clock_freq;
	ClkFreqConfig(clock_freq);
	SetConvFactor(clock_freq);
}

// Systick init with interrupt
void ClkInitIt(uint32_t clock_freq){
	freq = clock_freq;
	ClkFreqConfig(clock_freq);
	SetConvFactor(clock_freq);
	SysTick->CTRL |= 0x02;       // Enable Systick interrupt
}

// Conversion factors to use milliseconds as reference for timing
void SetConvFactor(uint32_t freq){
	if(freq == CLK_MICROS)
		conv_factor = MILLIS2MICROS;
	else if(freq == CLK_HUNDRED_MICROS)
		conv_factor = MILLIS2HUNDRED_MICROS;
	else if (freq == CLK_TENS_MICROS)
		conv_factor = MILLIS2TENS_MICROS;
	else
		conv_factor = 1;
}

// Systick callback
void SysTick_Handler(void){
	time_delay = (time_delay > 0)? time_delay-1 : 0;
	systicks++;
}

// Configure the frequency of the systick clock
void ClkFreqConfig(uint32_t clock_freq){
	SysTick->LOAD = clock_freq;  // Remember default systick freq for KL25Z is 21.9 Mhz
	SysTick->CTRL |= 0x05;     	 // Enable timer and set sysclk as source clock
}

// Get current systicks
uint64_t *GetSysTicks(void){
	return &systicks;
}

// Set delay ticks in current timing unit
void SetDelayTicks(uint32_t delay_ticks){
	time_delay = delay_ticks;
}

///// DELAY FUNCTIONS /////
void delayMs(uint32_t delay){
	// Manage different conversions according to time unit
	if(freq == CLK_MILLIS)
		time_delay = delay;
	else if (freq == CLK_HUNDRED_MICROS)
		time_delay = delay * 10;
	else if (freq == CLK_TENS_MICROS)
		time_delay = delay * 100;
	else
		time_delay = delay << 10;   // Multiplication cannot catch up at high speeds

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}

void delayUs(uint32_t delay){
	if (freq == CLK_MILLIS)
		time_delay = delay >> 10;
	else if(freq == CLK_HUNDRED_MICROS)
		time_delay = delay / 100;
	else if(freq == CLK_TENS_MICROS)
		time_delay = delay / 10;
	else
		time_delay = delay;

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/I2C_Display/Functions/rgb.c

#include "Headers/Rgb.h"

// Init RGB LED
void RGB_Init(void){
	// LED config
	SIM->SCGC5 |= 0x400;   // Enable clock port B
	SIM->SCGC5 |= 0x1000;  // Enable clock port D

	// Set pins as GPIOS
	PORTB->PCR[19] = 0x100;
	PORTB->PCR[18] = 0x100;
	PORTD->PCR[1] = 0x100;

	GPIOB->PDDR |= GREEN; // Enable (bit) pin 19 from GPIOB as output (Green)
	GPIOD->PDDR |= BLUE;  // Enable (bit) pin 1 from GPIOD as output (Blue)
	GPIOB->PDDR |= RED;   // Enable (bit) pin 18 from GPIOB as output (Red)

	RGB_Off();   // Set RGB Off after init
}

// Turn on LED
void LED_On(GPIO_Type *port, uint32_t pin){
	port->PDOR &= ~pin;
}

// Turn off LED
void LED_Off(GPIO_Type *port, uint32_t pin){
	port->PDOR |= pin;
}

// Toggle the LED
void LED_Toggle(GPIO_Type *port, uint32_t pin){
	port->PTOR |= pin;
}

// Set all LEDs On
void RGB_On(void){
	LED_On(GREEN_LED_PORT, GREEN);
	LED_On(BLUE_LED_PORT, BLUE);
	LED_On(RED_LED_PORT, RED);
}

// Set all LEDs Off
void RGB_Off(void){
	LED_Off(GREEN_LED_PORT, GREEN);
	LED_Off(BLUE_LED_PORT, BLUE);
	LED_Off(RED_LED_PORT, RED);
}

///////// Colors /////////
void GreenOn(void){
	LED_On(GREEN_LED_PORT, GREEN);
}

void BlueOn(void){
	LED_On(BLUE_LED_PORT, BLUE);
}

void RedOn(void){
	LED_On(RED_LED_PORT, RED);
}

void WhiteOn(void){
	RGB_On();
}

void YellowOn(void){
	GreenOn();
	RedOn();
}

void PurpleOn(void){
	RedOn();
	BlueOn();
}

///////// Colors Off /////////
void GreenOff(void){
	LED_Off(GREEN_LED_PORT, GREEN);
}

void BlueOff(void){
	LED_Off(BLUE_LED_PORT, BLUE);
}

void RedOff(void){
	LED_Off(RED_LED_PORT, RED);
}

void WhiteOff(void){
	RGB_Off();
}

void YellowOff(void){
	GreenOff();
	RedOff();
}

void PurpleOff(void){
	RedOff();
	BlueOff();
}

///////// Colors Toggle  /////////
void GreenToggle(void){
	LED_Toggle(GREEN_LED_PORT, GREEN);
}

void BlueToggle(void){
	LED_Toggle(BLUE_LED_PORT, BLUE);
}

void RedToggle(void){
	LED_Toggle(RED_LED_PORT, RED);
}

void WhiteToggle(void){
	GreenToggle();
	BlueToggle();
	RedToggle();
}

void YellowToggle(void){
	GreenToggle();
	RedToggle();
}
void PurpleToggle(void){
	BlueToggle();
	RedToggle();
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/Stepper/Stepper TPM/StepperTPM.c

#include "Headers/StepperTPM.h"

// Declare functions
static GPIO_Type* IdentifyGPIO(PORT_Type *);
static uint32_t ToBinaryGPIO(uint32_t);
static void PortConfigure(PORT_Type *);
static void SetPinLow(GPIO_Type *, uint32_t);
static void SetPinHigh(GPIO_Type *, uint32_t);
static void GPIO_Configure(PORT_Type *, uint32_t);

// Set initial motor states to Off
uint16_t StepperXFreq = 0;
uint16_t StepperYFreq = 0;
uint16_t StepperZFreq = 0;

// Initialize TPMs and GPIOs used for direction configuration
void SteppersInit(void){
	// TPMs Init
	AllTPMsInit();
	// Direction Pins init
	GPIO_Configure(STEPPERX_DIR_PORT, STEPPERX_DIR_PIN);
	GPIO_Configure(STEPPERY_DIR_PORT, STEPPERY_DIR_PIN);
	GPIO_Configure(STEPPERZ_DIR_PORT, STEPPERZ_DIR_PIN);
	// Set Direction
	StepperX_Direction(CLOCKWISE);
	StepperY_Direction(CLOCKWISE);
	StepperZ_Direction(CLOCKWISE);
	// Motors Off
	//SetMotorsOff();
}

// Initialize all TPMs
void AllTPMsInit(void){
	// Configure timers for the motors
	TPM0_Init();
	TPM1_Init();
	TPM2_Init();
}

// Configure the TPM0 timer (Stepper X) - Options: various pins on PORTD
void TPM0_Init(void) {
    // Enable clock to Port D
    SIM->SCGC5 |= SIM_SCGC5_PORTD_MASK;
    // Configure PTD0, PTD2, and PTD3 for TPM0 usage
    STEPPERX_PORT->PCR[STEPPERX_PIN] = PORT_PCR_MUX(4); // Channel 0 currently
    // Enable clock to TPM0
    SIM->SCGC6 |= SIM_SCGC6_TPM0_MASK;
    // Use MCGFLLCLK as the timer counter clock
    SIM->SOPT2 |= SIM_SOPT2_TPMSRC(1); // MCGFLLCLK
    // Disable TPM0 timer before configuration
    TPM0->SC = 0;
    // Configure TPM0 Channel 0 for edge-aligned PWM with high-true pulses
    TPM0->CONTROLS[0].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK;
    // Enable TPM0 with prescaler of 16 and edge-aligned mode
    TPM0->SC = TPM_SC_PS(3) | TPM_SC_CMOD(1); // Prescaler = 16, clock mode = 1
}

// Configure the TPM1 timer (Stepper Y) - Options: PTA12, PTA13
void TPM1_Init(void) {
    // Enable clock to Port A and Port E
    SIM->SCGC5 |= SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTE_MASK;
    // Configure PTA12 and PTA13 for TPM1 usage
    STEPPERY_PORT->PCR[STEPPERY_PIN] = PORT_PCR_MUX(3); // TPM1_CH0 currently
    // Enable clock to TPM1
    SIM->SCGC6 |= SIM_SCGC6_TPM1_MASK;
    // Use MCGFLLCLK as the timer counter clock
    SIM->SOPT2 |= SIM_SOPT2_TPMSRC(1);
    // Disable TPM1 timer before configuration
    TPM1->SC = 0;
    // Configure TPM1 channels for edge-aligned PWM with high-true pulses
    TPM1->CONTROLS[0].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK;
    // Enable TPM1 with prescaler of 16 and edge-aligned mode
    TPM1->SC = TPM_SC_PS(3) | TPM_SC_CMOD(1);
}

// Configure the TPM2 timer (Stepper Z) - Options: PTB18, PTB19
void TPM2_Init(void) {
    // Enable clock to Port A and Port B
    SIM->SCGC5 |= SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK;
    // Configure PTB18 and PTB19 for TPM2 usage
    STEPPERZ_PORT->PCR[STEPPERZ_PIN] = PORT_PCR_MUX(3); // TPM2_CH0 currently
    // Enable clock to TPM2
    SIM->SCGC6 |= SIM_SCGC6_TPM2_MASK;
    // Use MCGFLLCLK as the timer counter clock
    SIM->SOPT2 |= SIM_SOPT2_TPMSRC(1);
    // Disable TPM2 timer before configuration
    TPM2->SC = 0;
    // Configure TPM2 channels for edge-aligned PWM with high-true pulses
    TPM2->CONTROLS[0].CnSC = TPM_CnSC_MSB_MASK | TPM_CnSC_ELSB_MASK;
    // Enable TPM2 with prescaler of 16 and edge-aligned mode
    TPM2->SC = TPM_SC_PS(3) | TPM_SC_CMOD(1);
}

// Set the direction of the steppers
void StepperX_Direction(uint8_t direction){
	if(direction == CLOCKWISE){
		SetPinHigh(IdentifyGPIO(STEPPERX_DIR_PORT), ToBinaryGPIO(STEPPERX_DIR_PIN));
	}else{
		SetPinLow(IdentifyGPIO(STEPPERX_DIR_PORT), ToBinaryGPIO(STEPPERX_DIR_PIN));
	}
}

void StepperY_Direction(uint8_t direction){
	if(direction == CLOCKWISE){
		SetPinHigh(IdentifyGPIO(STEPPERY_DIR_PORT), ToBinaryGPIO(STEPPERY_DIR_PIN));
	}else{
		SetPinLow(IdentifyGPIO(STEPPERY_DIR_PORT), ToBinaryGPIO(STEPPERY_DIR_PIN));
	}
}

void StepperZ_Direction(uint8_t direction){
	if(direction == CLOCKWISE){
		SetPinHigh(IdentifyGPIO(STEPPERZ_DIR_PORT), ToBinaryGPIO(STEPPERZ_DIR_PIN));
	}else{
		SetPinLow(IdentifyGPIO(STEPPERZ_DIR_PORT), ToBinaryGPIO(STEPPERZ_DIR_PIN));
	}
}


// Set Stepper speed based on an input percentage
void StepperX_RunPercentage(uint8_t percentage){
	// Set an inferior limit
	if(percentage < 5){
		StepperX_Off();
	}else{
		// Calculate operating frequency based on maximum allowed frequency
		uint16_t frequency = (STEPPER_MAX_FREQUENCY_HZ * percentage) / 100;
		StepperX_RunFreq(frequency);
	}
}

void StepperY_RunPercentage(uint8_t percentage){
	// Set an inferior limit
	if(percentage < 5){
		StepperY_Off();
	}else{
		// Calculate operating frequency based on maximum allowed frequency
		uint16_t frequency = (STEPPER_MAX_FREQUENCY_HZ * percentage) / 100;
		StepperY_RunFreq(frequency);
	}
}

void StepperZ_RunPercentage(uint8_t percentage){
	// Set an inferior limit
	if(percentage < 5){
		StepperZ_Off();
	}else{
		// Calculate operating frequency based on maximum allowed frequency
		uint16_t frequency = (STEPPER_MAX_FREQUENCY_HZ * percentage) / 100;
		StepperZ_RunFreq(frequency);
	}
}

// Set all motors speed to the same specific speed
void RunMotorsPercentage(uint8_t percentage){
	StepperX_RunPercentage(percentage);
	StepperY_RunPercentage(percentage);
	StepperZ_RunPercentage(percentage);
}

// Run steppers to an specific frequency
void StepperX_RunFreq(uint16_t freq){
	// Calculate the mod for adjusting tpm frequency
	uint16_t tpm_mod = (TPM_FREQUENCY / freq) - 1;
	TPM0->MOD = tpm_mod;
	// Run to duty cycle 50%
	TPM0->CONTROLS[0].CnV = tpm_mod / 2;
	// Update global variable
	StepperXFreq = freq;
}

void StepperY_RunFreq(uint16_t freq){
	// Calculate the mod for adjusting tpm frequency
	uint16_t tpm_mod = (TPM_FREQUENCY / freq) - 1;
	TPM1->MOD = tpm_mod;
	// Run to duty cycle 50%
	TPM1->CONTROLS[0].CnV = tpm_mod / 2;
	// Update global variable
	StepperYFreq = freq;
}

void StepperZ_RunFreq(uint16_t freq){
	// Calculate the mod for adjusting tpm frequency
	uint16_t tpm_mod = (TPM_FREQUENCY / freq) - 1;
	TPM2->MOD = tpm_mod;
	// Run to duty cycle 50%
	TPM2->CONTROLS[0].CnV = tpm_mod / 2;
	// Update global variable
	StepperZFreq = freq;
}

// Individual motors off
void StepperX_Off(void){
	TPM0->CONTROLS[0].CnV = 0;
}

void StepperY_Off(void){
	TPM1->CONTROLS[0].CnV = 0;
}

void StepperZ_Off(void){
	TPM2->CONTROLS[0].CnV = 0;
}

// Set TPMs duty cycle to 0
void SetMotorsOff(void){
	// Set channel value for 0% duty cycle on Stepper X
	TPM0->CONTROLS[0].CnV = 0;
	// Set channel value for 0% duty cycle on Stepper Y
	TPM1->CONTROLS[0].CnV = 0;
	// Set channel value for 0% duty cycle on Stepper Z
	TPM2->CONTROLS[0].CnV = 0;
}

// Set TPM duty cycle to 50%
void SetMotorsOn(void){
	// Set channel value for 50% duty cycle on Stepper X
	TPM0->CONTROLS[0].CnV = StepperXFreq / 2;
	// Set channel value for 50% duty cycle on Stepper Y
	TPM1->CONTROLS[0].CnV = StepperYFreq / 2;
	// Set channel value for 50% duty cycle on Stepper Z
	TPM2->CONTROLS[0].CnV = StepperZFreq / 2;
}

// GPIO Management for direction set
static void SetPinHigh(GPIO_Type *port, uint32_t pin){
	port->PDOR |= pin;
}

static void SetPinLow(GPIO_Type *port, uint32_t pin){
	port->PDOR &= ~pin;
}

static GPIO_Type* IdentifyGPIO(PORT_Type *port){
	if(port == PORTA){
		return GPIOA;
	}else if(port == PORTB){
		return GPIOB;
	}else if(port == PORTC){
		return GPIOC;
	}else if(port == PORTD){
		return GPIOD;
	}else{
		return GPIOE;
	}
}

static void GPIO_Configure(PORT_Type *port, uint32_t pin){
	PortConfigure(port);
	port->PCR[pin] = 0x100;

	if(port == PORTA){
		GPIOA->PDDR |= ToBinaryGPIO(pin);    // Set as output
	}else if (port == PORTB){
		GPIOB->PDDR |= ToBinaryGPIO(pin);
	}else if (port == PORTC){
		GPIOC->PDDR |= ToBinaryGPIO(pin);
	}else if (port == PORTD){
		GPIOD->PDDR |= ToBinaryGPIO(pin);
	}else{
		GPIOE->PDDR |= ToBinaryGPIO(pin);
	}
}

static void PortConfigure(PORT_Type *port){
	if(port == PORTA){
		SIM->SCGC5 |= 0x200;   // Enable clock port A
	}else if (port == PORTB){
		SIM->SCGC5 |= 0x400;   // Enable clock port B
	}else if (port == PORTC){
		SIM->SCGC5 |= 0x800;   // Enable clock port C
	}else if (port == PORTD){
		SIM->SCGC5 |= 0x1000;  // Enable clock port D
	}else{
		SIM->SCGC5 |= 0x2000;  // Enable clock port E
	}
}

static uint32_t ToBinaryGPIO(uint32_t num){
	return (1 << num);
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/Stepper/Stepper Systick/Stepper.c

#include "Headers/Stepper.h"

static GPIO_Type* IdentifyGPIO(PORT_Type *);
static uint32_t ToBinaryGPIO(uint32_t);

Stepper CreateStepper(uint32_t stp_pin, PORT_Type* stp_port, uint32_t dir_pin,
					 PORT_Type* dir_port, uint32_t enable_pin, PORT_Type *enable_port){
	Stepper stepper;
	stepper.stp_pin = stp_pin;
	stepper.stp_port = stp_port;
	stepper.dir_pin = dir_pin;
	stepper.dir_port = dir_port;
	stepper.enable_pin = enable_pin;
	stepper.enable_port = enable_port;
	stepper.run = 1;
	return stepper;
}

void SetStepperSettings(Stepper* stepper, uint8_t dir,
						uint32_t step_delay, uint16_t steps_rev){
	stepper->direction = dir;
	stepper->step_delay = step_delay;
	stepper->steps_rev = steps_rev;
}

void SetStepperDirection(Stepper* stepper, uint8_t dir){
	stepper->direction = dir;
	GPIO_Type *dir_gpio = IdentifyGPIO(stepper->dir_port);
	if(dir == CLOCKWISE)
		SetPinHigh(dir_gpio, ToBinaryGPIO(stepper->dir_pin));
	else
		SetPinLow(dir_gpio, ToBinaryGPIO(stepper->dir_pin));
}

void SetStepperDelay(Stepper *stepper, uint32_t delay_micros){
	stepper->step_delay = delay_micros;
}

void StepperInit(Stepper *step_struct){
	// Configure GPIOs
	GPIO_Configure(step_struct->stp_port, step_struct->stp_pin);
	GPIO_Configure(step_struct->dir_port, step_struct->dir_pin);
	GPIO_Configure(step_struct->enable_port, step_struct->enable_pin);
	// Set default between steps delay (in microseconds)
	SetStepperDelay(step_struct, 4000);
	// Set default direction clockwise
	SetStepperDirection(step_struct, CLOCKWISE);
}

// Put this function inside a LOOP to move constantly (note that systicks should be less than millis)
void RunStepper(Stepper* stepper){
	GPIO_Type* stp_gpio = IdentifyGPIO(stepper->stp_port);

	if(stepper->run == 1){
		SetPinHigh(stp_gpio, ToBinaryGPIO(stepper->stp_pin));
		delayUs(stepper->step_delay);
		SetPinLow(stp_gpio, ToBinaryGPIO(stepper->stp_pin));
		delayUs(stepper->step_delay);
	}else{
		SetPinLow(stp_gpio, ToBinaryGPIO(stepper->stp_pin));
	}
}

/**
 * @brief This function sets the velocity of the motor given a resolution
 * Half of the resolution is set for counterclockwise and the rest for clockwise
 * */
void SetStepperVelocity(Stepper* stepper, uint8_t velocity){
	if(velocity >= (SPEED_RESOLUTION >> 1))
		SetStepperDirection(stepper, CLOCKWISE);
	else
		SetStepperDirection(stepper, COUNTERCLOCKWISE);
	velocity = (velocity >= (SPEED_RESOLUTION >> 1)? velocity - (SPEED_RESOLUTION >> 1) : velocity << 1);
	uint16_t delay_us = (MIN_US_DELAY * SPEED_RESOLUTION) / velocity;
	if(delay_us < MAX_US_DELAY){
		stepper->run = 1;
		SetStepperDelay(stepper, delay_us);
	}
	else{
		stepper->run = 0;
	}
}

/**
 * @brief A function to move certain number of millimeters in the current direction
 * */
void MoveMillimeters(Stepper *stepper, uint16_t millimeters){
	uint16_t counter = 0;  uint16_t desired_count = (millimeters / STEP_SIZE); // Check if it can handle float div
	stepper->run = 1;
	while(counter < desired_count){
		for(uint8_t i=0; i < stepper->steps_rev; i++){   // One spin
			RunStepper(stepper);
		}
	}
	stepper->run = 0;
	RunStepper(stepper);   // Turn stepper off
}

void StepperOff(Stepper* stepper){
	GPIO_Type* stp_gpio = IdentifyGPIO(stepper->stp_port);
	SetPinLow(stp_gpio, ToBinaryGPIO(stepper->stp_pin));
}

void SetPinHigh(GPIO_Type *port, uint32_t pin){
	port->PDOR |= pin;
}

void SetPinLow(GPIO_Type *port, uint32_t pin){
	port->PDOR &= ~pin;
}

static GPIO_Type* IdentifyGPIO(PORT_Type *port){
	if(port == PORTA){
		return GPIOA;
	}else if(port == PORTB){
		return GPIOB;
	}else if(port == PORTC){
		return GPIOC;
	}else if(port == PORTD){
		return GPIOD;
	}else{
		return GPIOE;
	}
}

void GPIO_Configure(PORT_Type *port, uint32_t pin){
	PortConfigure(port);
	port->PCR[pin] = 0x100;

	if(port == PORTA){
		GPIOA->PDDR |= ToBinaryGPIO(pin);    // Set as output
	}else if (port == PORTB){
		GPIOB->PDDR |= ToBinaryGPIO(pin);
	}else if (port == PORTC){
		GPIOC->PDDR |= ToBinaryGPIO(pin);
	}else if (port == PORTD){
		GPIOD->PDDR |= ToBinaryGPIO(pin);
	}else{
		GPIOE->PDDR |= ToBinaryGPIO(pin);
	}
}

void PortConfigure(PORT_Type *port){
	if(port == PORTA){
		SIM->SCGC5 |= 0x200;   // Enable clock port A
	}else if (port == PORTB){
		SIM->SCGC5 |= 0x400;   // Enable clock port B
	}else if (port == PORTC){
		SIM->SCGC5 |= 0x800;   // Enable clock port C
	}else if (port == PORTD){
		SIM->SCGC5 |= 0x1000;  // Enable clock port D
	}else{
		SIM->SCGC5 |= 0x2000;  // Enable clock port E
	}
}

static uint32_t ToBinaryGPIO(uint32_t num){
	return (1 << num);
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/Stepper/Stepper Systick/main.c

#include "main.h"

// Time aux
uint64_t blink_aux = 0, stepper_aux = 0;
// Systick pointer
const uint64_t *systicks;

int main(void){
	// Config functions
	ClkInitIt(CLK_TENS_MICROS);
	// Init RGB led
	RGB_Init();
	// Set systick pointer
	systicks = GetSysTicks();

	// Configure motor pins
	uint32_t stp_pin = 0;
	PORT_Type* stp_port = PORTC;
	uint32_t dir_pin = 7;
	PORT_Type* dir_port = PORTC;
	uint32_t enable_pin = 3;
	PORT_Type* enable_port = PORTC;

	// Run motor (step pin = C7, dir pin = C0)
	Stepper stp1 = CreateStepper(stp_pin, stp_port, dir_pin, dir_port,
								 enable_pin, enable_port);
	StepperInit(&stp1);

	// Main loop
	while(1){
		if(*systicks - stepper_aux >= TIME_TO_RUN_STEPPER * conv_factor){
			for(uint8_t i=0; i<200; i++){
				RunStepper(&stp1);
			}
			stepper_aux = *systicks;
		}

		// Blink led
		if(*systicks - blink_aux >= TIME_TO_BLINK_MS * conv_factor){
			YellowToggle();
			blink_aux = *systicks;
		}

	}
	return 0;
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/Stepper/Stepper Systick/Requirements/Clocks.c

#include "Headers/Clocks.h"

// Variables
static uint32_t freq;
static uint64_t systicks;
static uint32_t time_delay;
uint16_t conv_factor;

// Systick init
void ClkInit(uint32_t clock_freq){
	freq = clock_freq;
	ClkFreqConfig(clock_freq);
	SetConvFactor(clock_freq);
}

// Systick init with interrupt
void ClkInitIt(uint32_t clock_freq){
	freq = clock_freq;
	ClkFreqConfig(clock_freq);
	SetConvFactor(clock_freq);
	SysTick->CTRL |= 0x02;       // Enable Systick interrupt
}

// Conversion factors to use milliseconds as reference for timing
void SetConvFactor(uint32_t freq){
	if(freq == CLK_MICROS)
		conv_factor = MILLIS2MICROS;
	else if(freq == CLK_HUNDRED_MICROS)
		conv_factor = MILLIS2HUNDRED_MICROS;
	else if (freq == CLK_TENS_MICROS)
		conv_factor = MILLIS2TENS_MICROS;
	else
		conv_factor = 1;
}

// Systick callback
void SysTick_Handler(void){
	time_delay = (time_delay > 0)? time_delay-1 : 0;
	systicks++;
}

// Configure the frequency of the systick clock
void ClkFreqConfig(uint32_t clock_freq){
	SysTick->LOAD = clock_freq;  // Remember default systick freq for KL25Z is 21.9 Mhz
	SysTick->CTRL |= 0x05;     	 // Enable timer and set sysclk as source clock
}

// Get current systicks
uint64_t *GetSysTicks(void){
	return &systicks;
}

// Set delay ticks in current timing unit
void SetDelayTicks(uint32_t delay_ticks){
	time_delay = delay_ticks;
}

///// DELAY FUNCTIONS /////
void delayMs(uint32_t delay){
	// Manage different conversions according to time unit
	if(freq == CLK_MILLIS)
		time_delay = delay;
	else if (freq == CLK_HUNDRED_MICROS)
		time_delay = delay * 10;
	else if (freq == CLK_TENS_MICROS)
		time_delay = delay * 100;
	else
		time_delay = delay << 10;   // Multiplication cannot catch up at high speeds

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}

void delayUs(uint32_t delay){
	if (freq == CLK_MILLIS)
		time_delay = delay >> 10;
	else if(freq == CLK_HUNDRED_MICROS)
		time_delay = delay / 100;
	else if(freq == CLK_TENS_MICROS)
		time_delay = delay / 10;
	else
		time_delay = delay;

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/PIT Timer/PIT_Config.c

/*
 * This module is used to set a common time base for different events that require precise timing
 * using PIT module, which generates an interrupt every time the timer reaches a certain value
 * */

#include "Headers/PIT_Config.h"

uint64_t pit_delay;
uint8_t pit_timebase;

// Configure a PIT interrupt to run at a certain interval
void PIT_InitUs(void){
	// Enable clock for PIT
	SIM->SCGC6 |= SIM_SCGC6_PIT_MASK;
	// Enable PIT module and freeze timers in debug mode
	PIT->MCR = 0x00;
	// Set PIT0 reload value to generate an interrupt every 1 us
	PIT->CHANNEL[0].LDVAL = (SystemCoreClock / 2000000) - 1;  // The bus clock runs by default half the core clock freq (48Mhz/2= 24 Mhz)
	PIT->CHANNEL[0].TCTRL = PIT_TCTRL_TIE_MASK | PIT_TCTRL_TEN_MASK;
	// Update PIT timebase value
	pit_timebase = PIT_MICROSECONDS;
	// Enable PIT interrupt in NVIC
	NVIC_EnableIRQ(PIT_IRQn);
}

void PIT_InitMs(void){
	// Enable clock for PIT
	SIM->SCGC6 |= SIM_SCGC6_PIT_MASK;
	// Enable PIT module and freeze timers in debug mode
	PIT->MCR = 0x00;
	// Set PIT0 reload value to generate an interrupt every 1 us
	PIT->CHANNEL[0].LDVAL = (SystemCoreClock / 2000) - 1;
	PIT->CHANNEL[0].TCTRL = PIT_TCTRL_TIE_MASK | PIT_TCTRL_TEN_MASK;
	// Update PIT timebase value
	pit_timebase = PIT_MILLIS;
	// Enable PIT interrupt in NVIC
	NVIC_EnableIRQ(PIT_IRQn);
}

void PIT_IRQHandler(void){
	// Clear interrupt flag
	PIT->CHANNEL[0].TFLG = PIT_TFLG_TIF_MASK;
	// Manage delay library
	pit_delay = (pit_delay > 0)? pit_delay-1 : 0;
}

void PIT_DelayMicroseconds(uint64_t delay){
	pit_delay  = (pit_timebase == PIT_MICROSECONDS)? delay : 1; // If timebase is millis spend only one millisecond in cycle
	while(pit_delay != 0){}
}

void PIT_DelayMilliseconds(uint64_t delay){
	pit_delay  = (pit_timebase == PIT_MICROSECONDS)? delay*1000 : delay; // If timebase is millis spend only one millisecond in cycle
	while(pit_delay != 0){}
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/LCD 8 Bits/LCD_8BIT.c

#include "Headers/LCD_8BIT.h"

// Static functions
static GPIO_Type* IdentifyGPIO(PORT_Type *);
static uint32_t ToBinaryGPIO(uint32_t);
static void ConfigurePort(PORT_Type *);
static void ConfigureGPIO(PORT_Type *, uint32_t);
static void SetGPIOs(void);

// Variables
GPIO_Type *d0_gpio, *d1_gpio, *d2_gpio, *d3_gpio,
		   *d4_gpio, *d5_gpio, *d6_gpio, *d7_gpio;

GPIO_Type *enable_gpio, *rw_gpio, *rs_gpio;

// Default config struct
LCD8_Struct LCD8_defaultConfig = {
	// Ports
	.d0_port = PORTD, .d1_port = PORTD, .d2_port = PORTD, .d3_port = PORTD,
	.d4_port = PORTD, .d5_port = PORTD, .d6_port = PORTD, .d7_port = PORTD,
	.enable_port = PORTA, .rs_port = PORTA, .rw_port = PORTA,
	// Pins
	.d0_pin = 0, .d1_pin = 1, .d2_pin = 2, .d3_pin = 3,
	.d4_pin = 4, .d5_pin = 5, .d6_pin = 6, .d7_pin = 7,
	.enable_pin = 5, .rs_pin = 2, .rw_pin = 4
};

// LCD8 initialization
void LCD8_Init(void){
	// Configure GPIOs
	ConfigureGPIO(LCD8_defaultConfig.enable_port, LCD8_defaultConfig.enable_pin);
	ConfigureGPIO(LCD8_defaultConfig.rs_port, LCD8_defaultConfig.rs_pin);
	ConfigureGPIO(LCD8_defaultConfig.rw_port, LCD8_defaultConfig.rw_pin);
	// Data pins
	ConfigureGPIO(LCD8_defaultConfig.d0_port, LCD8_defaultConfig.d0_pin);
	ConfigureGPIO(LCD8_defaultConfig.d1_port, LCD8_defaultConfig.d1_pin);
	ConfigureGPIO(LCD8_defaultConfig.d2_port, LCD8_defaultConfig.d2_pin);
	ConfigureGPIO(LCD8_defaultConfig.d3_port, LCD8_defaultConfig.d3_pin);
	ConfigureGPIO(LCD8_defaultConfig.d4_port, LCD8_defaultConfig.d4_pin);
	ConfigureGPIO(LCD8_defaultConfig.d5_port, LCD8_defaultConfig.d5_pin);
	ConfigureGPIO(LCD8_defaultConfig.d6_port, LCD8_defaultConfig.d6_pin);
	ConfigureGPIO(LCD8_defaultConfig.d7_port, LCD8_defaultConfig.d7_pin);
	// Get the GPIOS with the port
	SetGPIOs();

	delayMs(20);
	LCD8_CommandNoWait(0x30);
	delayMs(5);
	LCD8_CommandNoWait(0x30);
	delayMs(1);
	LCD8_CommandNoWait(0x30);
	/* set 8-bit data, 2-line, 5x7 font */
	LCD8_Command(0x38);
	/* move cursor right */
	LCD8_Command(0x06);
	/* clear screen, move cursor to home */
	LCD8_Command(0x01);
	/* turn on display, cursor blinking */
	LCD8_Command(0x0F);
}

void LCD8_Command(unsigned char command){
	LCD8_Ready();
	rs_gpio->PCOR |= RS;
	rw_gpio->PCOR |= RW;
	d0_gpio->PDOR = command;
	enable_gpio->PSOR = EN;
	delayMs(0);
	enable_gpio->PCOR = EN;
}

void LCD8_CommandNoWait(unsigned char command){
	rs_gpio->PCOR |= RS;
	rw_gpio->PCOR |= RW;
	d0_gpio->PDOR = command;
	enable_gpio->PSOR = EN;
	delayMs(0);
	enable_gpio->PCOR = EN;
}

void LCD8_Data(unsigned char data){
	LCD8_Ready();
	rs_gpio->PCOR |= RS;
	rw_gpio->PCOR |= RW;
	d0_gpio->PDOR = data;
	enable_gpio->PSOR = EN;
	delayMs(0);
	enable_gpio->PCOR |= EN;
}

void LCD8_Ready(void){
	char status;
	d0_gpio->PDDR = 0;
	rs_gpio->PCOR = RS;
	rw_gpio->PSOR = RW;
	do{
		enable_gpio->PSOR = EN; // Raise En
		delayMs(0);
		status = d0_gpio->PDIR;
		enable_gpio->PCOR = EN;
		delayMs(0);
	}while(status & 0x80);   // Keep blocking while LCD8 is busy

	rw_gpio->PCOR = RW;
	d0_gpio->PDDR = 0xFF;
}

///// HIGHER LEVEL COMMANDS /////

// Clear the LCD and set the cursor to home
void LCD8_Clear(void){
	LCD8_Command(LCD8_CLEAR_COMMAND);
}

// Set LCD cursor to No blink
void LCD8_NoBlink(void){
	LCD8_Command(LCD8_NO_BLINK);
}

// Set cursor to blink
void LCD8_Blink(void){
	LCD8_Command(LCD8_BLINK_HOME);
}

void LCD8_Write(char *data)
{
	while(*data != '\0') // Loop through all the string, until null-terminator is found
	{
		LCD8_Ready();      // wait until LCD is ready
		rs_gpio->PSOR = RS;   // RS = 1, R/W = 0
		rw_gpio->PCOR = RW;   // readwrite
		d0_gpio->PDOR = *data;
		enable_gpio->PSOR = EN;   // pulse E
		delayMs(0);
		enable_gpio->PCOR = EN;
		data++;			 // Increment data pointer
	}
}

/////////////////////////////////


static void SetGPIOs(void){
	// Data pins
	d0_gpio = IdentifyGPIO(LCD8_defaultConfig.d0_port);
	d1_gpio = IdentifyGPIO(LCD8_defaultConfig.d1_port);
	d2_gpio = IdentifyGPIO(LCD8_defaultConfig.d2_port);
	d3_gpio = IdentifyGPIO(LCD8_defaultConfig.d3_port);
	d4_gpio = IdentifyGPIO(LCD8_defaultConfig.d4_port);
	d5_gpio = IdentifyGPIO(LCD8_defaultConfig.d5_port);
	d6_gpio = IdentifyGPIO(LCD8_defaultConfig.d6_port);
	d7_gpio = IdentifyGPIO(LCD8_defaultConfig.d7_port);
	// Additional pins
	enable_gpio = IdentifyGPIO(LCD8_defaultConfig.enable_port);
	rw_gpio = IdentifyGPIO(LCD8_defaultConfig.rw_port);
	rs_gpio = IdentifyGPIO(LCD8_defaultConfig.rs_port);
}

static void ConfigureGPIO(PORT_Type *port, uint32_t pin){
	ConfigurePort(port);
	port->PCR[pin] = 0x100;   // Set as GPIO

	if(port == PORTA){
		GPIOA->PDDR |= ToBinaryGPIO(pin);    // Set as output
	}else if (port == PORTB){
		GPIOB->PDDR |= ToBinaryGPIO(pin);
	}else if (port == PORTC){
		GPIOC->PDDR |= ToBinaryGPIO(pin);
	}else if (port == PORTD){
		GPIOD->PDDR |= ToBinaryGPIO(pin);
	}else{
		GPIOE->PDDR |= ToBinaryGPIO(pin);
	}
}

static void ConfigurePort(PORT_Type *port){
	if(port == PORTA){
		SIM->SCGC5 |= 0x200;   // Enable clock port A
	}else if (port == PORTB){
		SIM->SCGC5 |= 0x400;   // Enable clock port B
	}else if (port == PORTC){
		SIM->SCGC5 |= 0x800;   // Enable clock port C
	}else if (port == PORTD){
		SIM->SCGC5 |= 0x1000;  // Enable clock port D
	}else{
		SIM->SCGC5 |= 0x2000;  // Enable clock port E
	}
}

static GPIO_Type* IdentifyGPIO(PORT_Type *port){
	if(port == PORTA){
		return GPIOA;
	}else if(port == PORTB){
		return GPIOB;
	}else if(port == PORTC){
		return GPIOC;
	}else if(port == PORTD){
		return GPIOD;
	}else{
		return GPIOE;
	}
}

static uint32_t ToBinaryGPIO(uint32_t num){
	return (1 << num);
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/LCD 8 Bits/Requirements/Clocks.c

#include "Headers/Clocks.h"

// Variables
static uint8_t freq_index;
static uint32_t freq;
static uint64_t systicks;
static uint32_t time_delay;
uint16_t conv_factor;

// Configure the Multipurpose Clock Generator (MCG) - currently to 48 Mhz, bus clock to 8 Mhz
void MCG_Config(void){
	// MCG_C1: CLKS (bit 7-6) = 00
	MCG->C1 |= MCG_C1_CLKS(0);  // Select PLL/FLL as clock source
	// MCG_C1 : IREFS = 1
	MCG->C1 |= MCG_C1_IREFS(1);     // Select internal clock as FLL source
	//MCG->C1 |= MCG_C1_IRCLKEN(1);
	MCG->C2 |= MCG_C2_IRCS(0); 		// Enable slow internal clock (32 khz)

	MCG->C4 = MCG_C4_DMX32(1) | MCG_C4_DRST_DRS(1);  // Set to 48 Mhz FLL
	SIM->CLKDIV1 |= SIM_CLKDIV1_OUTDIV4(1);     // 48 Mhz/6 = 8Mhz bus clock

	SystemCoreClockUpdate(); // Update system core clock value
}

// Systick init
void ClkInit(uint8_t clock_freq){
	SystemCoreClockUpdate();
	freq_index = clock_freq;
	freq = MapFrequency(clock_freq);
	SetConvFactor(clock_freq);
	ClkFreqConfig(freq);
}

// Systick init with interrupt
void ClkInitIt(uint8_t clock_freq){
	SystemCoreClockUpdate();
	freq_index = clock_freq;
	freq = MapFrequency(clock_freq);
	SetConvFactor(clock_freq);
	ClkFreqConfig(freq);
	SysTick->CTRL |= 0x02;       // Enable Systick interrupt
}

// Map system core clock ticks to desired frequency
uint32_t MapFrequency(uint8_t desired_freq){
	switch(desired_freq){
	case CLK_MILLIS:
		return (SystemCoreClock/1000) - 1;
	case CLK_HUNDRED_MICROS:
		return (SystemCoreClock/10000) - 1;
	case CLK_TENS_MICROS:
		return (SystemCoreClock/100000) - 1;
	case CLK_MICROS:
		return (SystemCoreClock/1000000) - 1;
	default:
		return (SystemCoreClock/100000) - 1;    // Tens micros as default case
	}
}

// Conversion factors to use milliseconds as reference for timing
void SetConvFactor(uint8_t freq){
	if(freq == CLK_MICROS)
		conv_factor = MILLIS2MICROS;
	else if(freq == CLK_HUNDRED_MICROS)
		conv_factor = MILLIS2HUNDRED_MICROS;
	else if (freq == CLK_TENS_MICROS)
		conv_factor = MILLIS2TENS_MICROS;
	else
		conv_factor = 1;
}

// Systick callback
void SysTick_Handler(void){
	time_delay = (time_delay > 0)? time_delay-1 : 0;
	systicks++;
}

// Configure the frequency of the systick clock
void ClkFreqConfig(uint32_t clock_freq){
	SysTick->LOAD = clock_freq;  // Remember default systick freq for KL25Z is 21.9 Mhz
	SysTick->CTRL |= 0x05;     	 // Enable timer and set sysclk as source clock
}

// Get current systicks
uint64_t *GetSysTicks(void){
	return &systicks;
}

// Set delay ticks in current timing unit
void SetDelayTicks(uint32_t delay_ticks){
	time_delay = delay_ticks;
}

///// DELAY FUNCTIONS /////
void delayMs(uint32_t delay){
	// Manage different conversions according to time unit
	if(freq_index == CLK_MILLIS)
		time_delay = delay;
	else if (freq_index == CLK_HUNDRED_MICROS)
		time_delay = delay * 10;
	else if (freq_index == CLK_TENS_MICROS)
		time_delay = delay * 100;
	else
		time_delay = delay << 10;   // Multiplication cannot catch up at high speeds

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}

void delayUs(uint32_t delay){
	if (freq_index == CLK_MILLIS)
		time_delay = delay >> 10;
	else if(freq_index == CLK_HUNDRED_MICROS)
		time_delay = delay / 100;
	else if(freq_index == CLK_TENS_MICROS)
		time_delay = delay / 10;
	else
		time_delay = delay;

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/LCD4_Bits/LCD_4BIT.c

#include "Headers/LCD_4BIT.h"

// Static functions
static GPIO_Type* IdentifyGPIO(PORT_Type *);
static uint32_t ToBinaryGPIO(uint32_t);
static void ConfigurePort(PORT_Type *);
static void ConfigureGPIO(PORT_Type *, uint32_t);
static void SetGPIOs(void);
static void SendNibble(unsigned char nibble);

// Variables
GPIO_Type *d4_gpio, *d5_gpio, *d6_gpio, *d7_gpio;
GPIO_Type *enable_gpio, *rw_gpio, *rs_gpio;

// Default config struct
LCD4_Struct LCD4_defaultConfig = {
    // Ports
    .d4_port = PORTD, .d5_port = PORTD, .d6_port = PORTD, .d7_port = PORTD,
    .enable_port = PORTA, .rs_port = PORTA, .rw_port = PORTA,
    // Pins
    .d4_pin = 4, .d5_pin = 5, .d6_pin = 6, .d7_pin = 7,
    .enable_pin = 5, .rs_pin = 2, .rw_pin = 4
};

// LCD4 initialization
void LCD4_Init(void){
    // Configure GPIOs
    ConfigureGPIO(LCD4_defaultConfig.enable_port, LCD4_defaultConfig.enable_pin);
    ConfigureGPIO(LCD4_defaultConfig.rs_port, LCD4_defaultConfig.rs_pin);
    ConfigureGPIO(LCD4_defaultConfig.rw_port, LCD4_defaultConfig.rw_pin);
    // Data pins
    ConfigureGPIO(LCD4_defaultConfig.d4_port, LCD4_defaultConfig.d4_pin);
    ConfigureGPIO(LCD4_defaultConfig.d5_port, LCD4_defaultConfig.d5_pin);
    ConfigureGPIO(LCD4_defaultConfig.d6_port, LCD4_defaultConfig.d6_pin);
    ConfigureGPIO(LCD4_defaultConfig.d7_port, LCD4_defaultConfig.d7_pin);
    // Get the GPIOS with the port
    SetGPIOs();

    delayMs(10);
    LCD4_CommandNoWait(0x02);  // Initialize to 4-bit mode
    LCD4_Command(0x28);  // Function set: 4-bit, 2-line, 5x7 dots
    LCD4_Command(0x06);  // Entry mode set: increment cursor, no shift
    LCD4_Command(0x0F);  // Display on, cursor blinking
    LCD4_Command(0x01);  // Clear display
    delayUs(1090);
}

void LCD4_Command(unsigned char command){
    LCD4_Ready();
    rs_gpio->PCOR |= RS;
    rw_gpio->PCOR |= RW;
    SendNibble(command >> 4);  // Send high nibble
    delayUs(40);
    SendNibble(command & 0x0F);  // Send low nibble
}

void LCD4_CommandNoWait(unsigned char command){
    rs_gpio->PCOR |= RS;
    rw_gpio->PCOR |= RW;
    SendNibble(command >> 4);  // Send high nibble
    SendNibble(command & 0x0F);  // Send low nibble
    delayUs(40);
}

void LCD4_Data(unsigned char data){
    LCD4_Ready();
    rs_gpio->PSOR = RS;
    rw_gpio->PCOR = RW;
    SendNibble(data >> 4);  // Send high nibble
    SendNibble(data & 0x0F);  // Send low nibble
}

void LCD4_Ready(void){
    char status;
    d4_gpio->PDDR = 0;
    rs_gpio->PCOR = RS;
    rw_gpio->PSOR = RW;
    do{
        enable_gpio->PSOR = EN;  // Raise En
        delayMs(0);
        status = (d7_gpio->PDIR & (1 << LCD4_defaultConfig.d7_pin)) >> LCD4_defaultConfig.d7_pin;
        enable_gpio->PCOR = EN;
        delayMs(0);
    }while(status & 0x80);  // Keep blocking while LCD4 is busy

    rw_gpio->PCOR = RW;
    d4_gpio->PDDR = 0xFF;
    d5_gpio->PDDR = 0xFF;
    d6_gpio->PDDR = 0xFF;
    d7_gpio->PDDR = 0xFF;
}

// Higher level commands
void LCD4_Clear(void){
    LCD4_Command(LCD4_CLEAR_COMMAND);
}

void LCD4_NoBlink(void){
    LCD4_Command(LCD4_NO_BLINK);
}

void LCD4_Blink(void){
    LCD4_Command(LCD4_BLINK_HOME);
}

void LCD4_Write(char *data){
    while(*data != '\0'){
        LCD4_Data(*data);
        data++;
        delayUs(500);
    }
}

// Static functions
static void SetGPIOs(void){
    // Data pins
    d4_gpio = IdentifyGPIO(LCD4_defaultConfig.d4_port);
    d5_gpio = IdentifyGPIO(LCD4_defaultConfig.d5_port);
    d6_gpio = IdentifyGPIO(LCD4_defaultConfig.d6_port);
    d7_gpio = IdentifyGPIO(LCD4_defaultConfig.d7_port);
    // Additional pins
    enable_gpio = IdentifyGPIO(LCD4_defaultConfig.enable_port);
    rw_gpio = IdentifyGPIO(LCD4_defaultConfig.rw_port);
    rs_gpio = IdentifyGPIO(LCD4_defaultConfig.rs_port);
}

static void ConfigureGPIO(PORT_Type *port, uint32_t pin){
    ConfigurePort(port);
    port->PCR[pin] = 0x100;  // Set as GPIO

    if(port == PORTA){
        GPIOA->PDDR |= ToBinaryGPIO(pin);  // Set as output
    }else if (port == PORTB){
        GPIOB->PDDR |= ToBinaryGPIO(pin);
    }else if (port == PORTC){
        GPIOC->PDDR |= ToBinaryGPIO(pin);
    }else if (port == PORTD){
        GPIOD->PDDR |= ToBinaryGPIO(pin);
    }else{
        GPIOE->PDDR |= ToBinaryGPIO(pin);
    }
}

static void ConfigurePort(PORT_Type *port){
    if(port == PORTA){
        SIM->SCGC5 |= 0x200;  // Enable clock port A
    }else if (port == PORTB){
        SIM->SCGC5 |= 0x400;  // Enable clock port B
    }else if (port == PORTC){
        SIM->SCGC5 |= 0x800;  // Enable clock port C
    }else if (port == PORTD){
        SIM->SCGC5 |= 0x1000;  // Enable clock port D
    }else{
        SIM->SCGC5 |= 0x2000;  // Enable clock port E
    }
}

static GPIO_Type* IdentifyGPIO(PORT_Type *port){
    if(port == PORTA){
        return GPIOA;
    }else if(port == PORTB){
        return GPIOB;
    }else if(port == PORTC){
        return GPIOC;
    }else if(port == PORTD){
        return GPIOD;
    }else{
        return GPIOE;
    }
}


static uint32_t ToBinaryGPIO(uint32_t num){
    return (1 << num);
}

static void SendNibble(unsigned char nibble){
    // Clear previous data
    d4_gpio->PCOR = ToBinaryGPIO(LCD4_defaultConfig.d4_pin);
    d5_gpio->PCOR = ToBinaryGPIO(LCD4_defaultConfig.d5_pin);
    d6_gpio->PCOR = ToBinaryGPIO(LCD4_defaultConfig.d6_pin);
    d7_gpio->PCOR = ToBinaryGPIO(LCD4_defaultConfig.d7_pin);

    // Set new data
    if(nibble & 0x01) d4_gpio->PSOR = ToBinaryGPIO(LCD4_defaultConfig.d4_pin);
    if(nibble & 0x02) d5_gpio->PSOR = ToBinaryGPIO(LCD4_defaultConfig.d5_pin);
    if(nibble & 0x04) d6_gpio->PSOR = ToBinaryGPIO(LCD4_defaultConfig.d6_pin);
    if(nibble & 0x08) d7_gpio->PSOR = ToBinaryGPIO(LCD4_defaultConfig.d7_pin);

    // Pulse enable
    enable_gpio->PSOR = EN;
    delayMs(0);
    enable_gpio->PCOR = EN;
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/LCD4_Bits/Requirements/Clocks.c

#include "Headers/Clocks.h"

// Variables
static uint8_t freq_index;
static uint32_t freq;
static uint64_t systicks;
static uint32_t time_delay;
uint16_t conv_factor;

// Configure the Multipurpose Clock Generator (MCG) - currently to 48 Mhz, bus clock to 8 Mhz
void MCG_Config(void){
	// MCG_C1: CLKS (bit 7-6) = 00
	MCG->C1 |= MCG_C1_CLKS(0);  // Select PLL/FLL as clock source
	// MCG_C1 : IREFS = 1
	MCG->C1 |= MCG_C1_IREFS(1);     // Select internal clock as FLL source
	//MCG->C1 |= MCG_C1_IRCLKEN(1);
	MCG->C2 |= MCG_C2_IRCS(0); 		// Enable slow internal clock (32 khz)

	MCG->C4 = MCG_C4_DMX32(1) | MCG_C4_DRST_DRS(1);  // Set to 48 Mhz FLL
	SIM->CLKDIV1 |= SIM_CLKDIV1_OUTDIV4(1);     // 48 Mhz/6 = 8Mhz bus clock

	SystemCoreClockUpdate(); // Update system core clock value
}

// Systick init
void ClkInit(uint8_t clock_freq){
	SystemCoreClockUpdate();
	freq_index = clock_freq;
	freq = MapFrequency(clock_freq);
	SetConvFactor(clock_freq);
	ClkFreqConfig(freq);
}

// Systick init with interrupt
void ClkInitIt(uint8_t clock_freq){
	SystemCoreClockUpdate();
	freq_index = clock_freq;
	freq = MapFrequency(clock_freq);
	SetConvFactor(clock_freq);
	ClkFreqConfig(freq);
	SysTick->CTRL |= 0x02;       // Enable Systick interrupt
}

// Map system core clock ticks to desired frequency
uint32_t MapFrequency(uint8_t desired_freq){
	switch(desired_freq){
	case CLK_MILLIS:
		return (SystemCoreClock/1000) - 1;
	case CLK_HUNDRED_MICROS:
		return (SystemCoreClock/10000) - 1;
	case CLK_TENS_MICROS:
		return (SystemCoreClock/100000) - 1;
	case CLK_MICROS:
		return (SystemCoreClock/1000000) - 1;
	default:
		return (SystemCoreClock/100000) - 1;    // Tens micros as default case
	}
}

// Conversion factors to use milliseconds as reference for timing
void SetConvFactor(uint8_t freq){
	if(freq == CLK_MICROS)
		conv_factor = MILLIS2MICROS;
	else if(freq == CLK_HUNDRED_MICROS)
		conv_factor = MILLIS2HUNDRED_MICROS;
	else if (freq == CLK_TENS_MICROS)
		conv_factor = MILLIS2TENS_MICROS;
	else
		conv_factor = 1;
}

// Systick callback
void SysTick_Handler(void){
	time_delay = (time_delay > 0)? time_delay-1 : 0;
	systicks++;
}

// Configure the frequency of the systick clock
void ClkFreqConfig(uint32_t clock_freq){
	SysTick->LOAD = clock_freq;  // Remember default systick freq for KL25Z is 21.9 Mhz
	SysTick->CTRL |= 0x05;     	 // Enable timer and set sysclk as source clock
}

// Get current systicks
uint64_t *GetSysTicks(void){
	return &systicks;
}

// Set delay ticks in current timing unit
void SetDelayTicks(uint32_t delay_ticks){
	time_delay = delay_ticks;
}

///// DELAY FUNCTIONS /////
void delayMs(uint32_t delay){
	// Manage different conversions according to time unit
	if(freq_index == CLK_MILLIS)
		time_delay = delay;
	else if (freq_index == CLK_HUNDRED_MICROS)
		time_delay = delay * 10;
	else if (freq_index == CLK_TENS_MICROS)
		time_delay = delay * 100;
	else
		time_delay = delay << 10;   // Multiplication cannot catch up at high speeds

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}

void delayUs(uint32_t delay){
	if (freq_index == CLK_MILLIS)
		time_delay = delay >> 10;
	else if(freq_index == CLK_HUNDRED_MICROS)
		time_delay = delay / 100;
	else if(freq_index == CLK_TENS_MICROS)
		time_delay = delay / 10;
	else
		time_delay = delay;

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/UART Handler/UART.c

#include "Headers/UART.h"

// NOTE: UART0 is clocked directly from MCGFLLCLK unlike other peripherals
// which are clocked by the bus/flash clock

static void AccumString(char);

// Buffer settings
uint16_t tx_size = 0, rx_size = 0;
char *tx_buffer;
char *rx_buffer;
// Buffer iterators
volatile uint16_t current_tx = 0, current_rx = 0;

//////// Set Buffers ////////
void SetRX_Buffer(char *buff, uint16_t size){
	rx_size = size;
	rx_buffer = buff;
}

void SetTX_Buffer(char *buff, uint16_t size){
	tx_size = size;
	tx_buffer = buff;
}

void UART0_Config(uint8_t mode, uint32_t baud_rate) {
	// Get variables for mode config
	uint8_t interrupt_rx = (mode == 1)? 1 : 0;
	uint8_t interrupt_tx = (mode == 2)? 1 : 0;
	if(mode == 3){interrupt_rx = 1; interrupt_tx = 1;}
    // Clocks
	SIM->SCGC4 |= 0x400;	   // Enable clock for UART0
	SIM->SOPT2 |= 0x4000000;   // Specify clock
    // Baud Rate
    uint32_t baud_bits[2];
    IdentifyBaudRate(baud_rate, baud_bits);
	UART0->BDH = baud_bits[0];
	UART0->BDL = baud_bits[1]; // Custom baud rate
    // Configurations
    UART0->C1 = 0x00;  // 8-bit data, no parity
    UART0->C2 |= UART_C2_TE_MASK | UART_C2_RE_MASK; // Enable transmitter and receiver
    UART0->C4 |= 0x0F;	 				// Enable oversampling to 16
    SIM->SCGC5 |= SIM_SCGC5_PORTA_MASK; // Enable clock for PORTA
    PORTA->PCR[1] = PORT_PCR_MUX(2);    // Set PTA1 to UART0_RX
    PORTA->PCR[2] = PORT_PCR_MUX(2);    // Set PTA2 to UART0_TX
    // MODE EVALUATION
    if(interrupt_rx == 1){ UART0->C2 |= (1 << 5);}  // Enable receive interrupt
    if(interrupt_tx == 1){ UART0->C2 |= (1 << 6);}  // Enable transmission complete interrupt
    if(mode != 0){NVIC_EnableIRQ(UART0_IRQn);}      // Enable interrupt with NVIC
}

/**
 * @brief Function to get the BDH and BDL values to configure for a certain baud rate
 * */
void IdentifyBaudRate(uint32_t baud_rate, uint32_t bits[2]){
	uint32_t bdh = 0x00, bdl = 0x00;
	if(baud_rate == baud1){

	} else if(baud_rate == baud2){

	} else if(baud_rate == baud3){

	} else if(baud_rate == baud4){ bdh = BAUD4_BDH; bdl = BAUD4_BDL;
	} else if(baud_rate == baud5){

	} else if(baud_rate == baud6){

	} else if(baud_rate == baud7){

	} else if(baud_rate == baud8){

	} else if(baud_rate == baud9){bdh = BAUD9_BDH; bdl = BAUD9_BDL;
	} else{
	}
	// Modify array values directly
	bits[0] = bdh;
	bits[1] = bdl;
}

void UART_Send(void){
	for(uint8_t i=0; i < strlen(tx_buffer); i++){
		if(*(tx_buffer + i) == '\n' || *(tx_buffer + i) == '\0'){
			break;
		}else{
			while (!(UART0->S1 & UART_S1_TDRE_MASK)); // Wait for the transmit internal buffer to be empty
			UART0->D = *(tx_buffer + i);
		}
	}
}

// Callback for UART0 interrupt (An event related to UART0 has happened)
void UART0_IRQHandler(void) {
	BlueToggle();
	// Manage data reception
    if(UART0->S1 & UART_S1_RDRF_MASK) {
        char c = UART0->D;
        AccumString(c);
    }
}

static void AccumString(char c){
	// Manage overflow
	if(current_rx >= rx_size - 1 || current_rx < 0){
		*rx_buffer = '\0';   // Set to NULL first element of buffer
		current_tx = 0;      // Reset current rx index to 0 (reset the message)
	}
	// Otherwise, a normal operation
	if(c == ' '){
		*(rx_buffer + current_rx) = '\0';  // End string
		current_rx = 0;
		return;
	}else{
		*(rx_buffer + current_rx) = c;  // Update character
		current_rx++;
	}
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Custom Libraries/Systick Config/Clocks.c

#include "Headers/Clocks.h"

// Variables
static uint8_t freq_index;
static uint32_t freq;
static uint64_t systicks;
static uint32_t time_delay;
uint16_t conv_factor;

// Configure the Multipurpose Clock Generator (MCG) - currently to 48 Mhz, bus clock to 8 Mhz
void MCG_Config(void){
	// MCG_C1: CLKS (bit 7-6) = 00
	MCG->C1 |= MCG_C1_CLKS(0);  // Select PLL/FLL as clock source
	// MCG_C1 : IREFS = 1
	MCG->C1 |= MCG_C1_IREFS(1);     // Select internal clock as FLL source
	//MCG->C1 |= MCG_C1_IRCLKEN(1);
	MCG->C2 |= MCG_C2_IRCS(0); 		// Enable slow internal clock (32 khz)

	MCG->C4 = MCG_C4_DMX32(1) | MCG_C4_DRST_DRS(1);  // Set to 48 Mhz FLL
	SIM->CLKDIV1 |= SIM_CLKDIV1_OUTDIV4(1);     // 48 Mhz/6 = 8Mhz bus clock

	SystemCoreClockUpdate(); // Update system core clock value
}

// Systick init
void ClkInit(uint8_t clock_freq){
	SystemCoreClockUpdate();
	freq_index = clock_freq;
	freq = MapFrequency(clock_freq);
	SetConvFactor(clock_freq);
	ClkFreqConfig(freq);
}

// Systick init with interrupt
void ClkInitIt(uint8_t clock_freq){
	SystemCoreClockUpdate();
	freq_index = clock_freq;
	freq = MapFrequency(clock_freq);
	SetConvFactor(clock_freq);
	ClkFreqConfig(freq);
	SysTick->CTRL |= 0x02;       // Enable Systick interrupt
}

// Map system core clock ticks to desired frequency
uint32_t MapFrequency(uint8_t desired_freq){
	switch(desired_freq){
	case CLK_MILLIS:
		return (SystemCoreClock/1000) - 1;
	case CLK_HUNDRED_MICROS:
		return (SystemCoreClock/10000) - 1;
	case CLK_TENS_MICROS:
		return (SystemCoreClock/100000) - 1;
	case CLK_MICROS:
		return (SystemCoreClock/1000000) - 1;
	default:
		return (SystemCoreClock/100000) - 1;    // Tens micros as default case
	}
}

// Conversion factors to use milliseconds as reference for timing
void SetConvFactor(uint8_t freq){
	if(freq == CLK_MICROS)
		conv_factor = MILLIS2MICROS;
	else if(freq == CLK_HUNDRED_MICROS)
		conv_factor = MILLIS2HUNDRED_MICROS;
	else if (freq == CLK_TENS_MICROS)
		conv_factor = MILLIS2TENS_MICROS;
	else
		conv_factor = 1;
}

// Systick callback
void SysTick_Handler(void){
	time_delay = (time_delay > 0)? time_delay-1 : 0;
	systicks++;
}

// Configure the frequency of the systick clock
void ClkFreqConfig(uint32_t clock_freq){
	SysTick->LOAD = clock_freq;  // Remember default systick freq for KL25Z is 21.9 Mhz
	SysTick->CTRL |= 0x05;     	 // Enable timer and set sysclk as source clock
}

// Get current systicks
uint64_t *GetSysTicks(void){
	return &systicks;
}

// Set delay ticks in current timing unit
void SetDelayTicks(uint32_t delay_ticks){
	time_delay = delay_ticks;
}

///// DELAY FUNCTIONS /////
void delayMs(uint32_t delay){
	// Manage different conversions according to time unit
	if(freq_index == CLK_MILLIS)
		time_delay = delay;
	else if (freq_index == CLK_HUNDRED_MICROS)
		time_delay = delay * 10;
	else if (freq_index == CLK_TENS_MICROS)
		time_delay = delay * 100;
	else
		time_delay = delay << 10;   // Multiplication cannot catch up at high speeds

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}

void delayUs(uint32_t delay){
	if (freq_index == CLK_MILLIS)
		time_delay = delay >> 10;
	else if(freq_index == CLK_HUNDRED_MICROS)
		time_delay = delay / 100;
	else if(freq_index == CLK_TENS_MICROS)
		time_delay = delay / 10;
	else
		time_delay = delay;

	// Do nothing until time_delay goes back to 0
	while(time_delay != 0){
	}
}


==================================================

File: /Users/pablovargas/Documents/repos/Polo280-KL25Z_Labs-d9994ca/Protocols/UART_PRINT.c

// Print to Console using UART polling
#include "main.h"

// Config functions
static void UART_Config(void);
static void GPIO_Config(void);
static void ClockConfig(void);

// Functionalities
static void delayMs(uint16_t);
static void LED_On(GPIO_Type *, uint32_t);
static void LED_Off(GPIO_Type *, uint32_t);
static void LED_Toggle(GPIO_Type *, uint32_t);
static void ResetWatchDog(void);

// Variables
uint64_t millis = 0;
uint64_t blink_aux = 0, print_aux = 0;
char uart_c[50];

int main(void){
	// Clock configure
	ClockConfig();
	// Configure GPIOs
	GPIO_Config();
	// Configure UART channel
	UART_Config();

	// Turn off LEDS
	GPIOD->PDOR |= 0x02;        // Blue
	GPIOB->PDOR |= 0x40000;     // Red
	GPIOB->PDOR |= 0x80000;     // Green

	// Starting sequence
	LED_On(GPIOB, GREEN);
	delayMs(3000);
	LED_Off(GPIOB, GREEN);

	// UART message
	strcpy(uart_c, "hello\n");

	// Main loop
	while(1){
		//ResetWatchDog();

		// Keep the current count in milliseconds since program started
		if(SysTick->CTRL & 0x10000){
			millis ++;
		}

		// Print in UART0
		if(millis - print_aux >= TIME_TO_PRINT_MS){
			for(uint8_t i=0; i < strlen(uart_c); i++){
				UART0->D = uart_c[i];
				while(!(UART0->S1 & 0x40)){  // Wait for the TX buffer to be empty
					if(millis - print_aux >= UART_TIMEOUT_MS){
						print_aux = millis;
						break;
					}
				}
			}
			print_aux = millis;
		}

		// Toggle the LED each second
		if(millis - blink_aux >= TIME_TO_BLINK_MS){
			LED_Toggle(GPIOD, BLUE);
			blink_aux = millis;
		}
	}
	return 0;
}

// Function to configure clocks
void ClockConfig(void){
	// Systick clock frequency = 21 Mhz
	SysTick->LOAD = 21799;    	 // Remember default systick freq for KL25Z is 41.94 Mhz
	SysTick->CTRL |= 0x05;     	 // Enable timer and set sysclk as source clock
	//SysTick->CTRL |= 0x02;     // Enable Systick interrupt

	// Configure watchdog
	SIM->COPC = 0x0C;
}

// Function to configure GPIOs
void GPIO_Config(void){
	// LED config
	SIM->SCGC5 |= 0x400;   // Enable clock port B
	SIM->SCGC5 |= 0x1000;  // Enable clock port D

	// Set pins as GPIOS
	PORTB->PCR[19] = 0x100;
	PORTB->PCR[18] = 0x100;
	PORTD->PCR[1] = 0x100;

	GPIOB->PDDR |= 0x80000;  // Enable (bit) pin 19 from GPIOB as output (Green)
	GPIOD->PDDR |= 0x02;     // Enable (bit) pin 1 from GPIOD as output (Blue)
	GPIOB->PDDR |= 0x40000;  // Enable (bit) pin 18 from GPIOB as output (Red)
}

// Function to configure UART channels
void UART_Config(void){
	// Clocks
	SIM->SCGC4 |= 0x400;	   // Enable clock for UART0
	SIM->SOPT2 |= 0x4000000;   // Specify clock
	// Baud Rate
	UART0->BDH = 0x00;
	UART0->BDL = 0x0C;         // Baud Rate = 115200
	// Configurations
	UART0->C1 |= 0x80;  	   // UART RX and TX in different pins (normal operation)
	UART0->C2 |= 0x08;		   // Enable UART Transmitter
	UART0->C4 |= 0x0F;		   // Enable oversampling to 16
	// Ports
	SIM->SCGC5 |= 0x200;       // Enable clock for PORTA
	PORTA->PCR[2] = 0x0200;    // Make PTA2 UART0 Pin
}

// Turn on LED
void LED_On(GPIO_Type *port, uint32_t pin){
	port->PDOR &= ~pin;
}

// Turn off LED
void LED_Off(GPIO_Type *port, uint32_t pin){
	port->PDOR |= pin;
}

// Toggle the LED
void LED_Toggle(GPIO_Type *port, uint32_t pin){
	port->PTOR |= pin;
}

// A function to reset watchdog
void ResetWatchDog(void){
	// Reset watchdog
	SIM->SRVCOP = 0x55;
	SIM->SRVCOP = 0xAA;
}

// Delay in milliseconds
void delayMs(uint16_t millis){   // Use the systick timer module
	uint64_t counter = 0;

	// Check until current count = millis
	while(counter < millis){
		if(SysTick->CTRL & 0x10000){
			counter ++;
		}
	}
}


==================================================
